{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TM Admin","text":"<p> Administrative modules for Tasking Manager style projects. </p> <p> </p> <p>\ud83d\udcd6 Documentation: https://hotosm.github.io/tm-admin/</p> <p>\ud83d\udda5\ufe0f Source Code: https://github.com/hotosm/tm-admin</p> <p>This is a complicated project as it involves parsing and outputting multiple file formats. This project uses gRPC for the low-level communication layer, which is below the REST API. This way it can be used by multiple other project REST APIs for exchanging data without massive refactoring of an existing API.</p> <p>The database schema is based on the ones in use in the FMTM project, which were originally based on the ones used by the HOT Tasking Manager. The schemas have years of improvements on the data requirements of Tasking Manager style projects. Not every column in a database table will be needed by each project, they can be ignored. It should be entirely possible to use a custom configuration file, but this is currently unsupported. (would love a patch for this)</p> <p>This project generates multiple files at runtime, so each is organized into a sub-directory, one for each table. The program that processes each configuration file is generator.py, which is part of this project. This reads in a configuration file in YAML format, and generates the output files for this configuration file. There is also a class Generator that can be used by other projects.</p> <p>These are the current modules supported by this project.</p> <ul> <li>users</li> <li>projects</li> <li>tasks</li> <li>organizations</li> <li>teams</li> </ul>"},{"location":"#tmadmin-manage","title":"tmadmin-manage","text":"<p>The tmadmin-manage program is for higher-level data management. While each class can be run standalone, that's more for testing &amp; development. This program is also both a standalone program, and a class that can be used by other projects. This program will create the database and tables for each module.</p>"},{"location":"#datatypes","title":"Datatypes","text":"<p>Each database table has it's own configuration file. There is also a top level one, types.yaml that generates the type definitions that all the other files depend on. This becomes types_tm.sql, types_tm.proto, and types_tm.py, and needs to be imported before the other files.</p>"},{"location":"#yaml-files","title":".yaml files","text":"<p>The YAML based config files are where everything gets defined. This way a single configuration file can be used to generate multiple output formats. In the case of this projects, that's SQL files for a local postgres database, protobuf files for gRPC, and python source files for data type definitions. There is more information on the configuration files here</p>"},{"location":"#proto-files","title":".proto files","text":"<p>These define the messages used by gRPC, and are also generated from the configuration files. Not every column in the database tables is in a message. The fields that get send and received are defined in the configuration file by adding share: True as a setting.</p> <p>The .proto files then have to be compiled using protoc, which  generates the client and server stubs.</p>"},{"location":"#sql-files","title":".sql files","text":"<p>These define the messages used by gRPC, and are also generated from the configuration files. These can be executed in postgres to create the tables. The tmadmin-manage program uses these to create the database tables.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#unreleased","title":"Unreleased","text":""},{"location":"CHANGELOG/#fix","title":"Fix","text":"<ul> <li>refactor importing invalidation history</li> <li>Don't create the database by default, it's now an option</li> <li>Add comment about int vs int array</li> <li>Add some block comments for mkdocs</li> <li>Refactor to update the array of nested tables for history</li> <li>Drop outline, it's a duplicate of geometry, which is what TM uses</li> <li>fix: Add the id and project_id so they're in the SQL query</li> <li>Add the id and project_id so they're in the SQL query</li> <li>Process WKB for points correctly</li> <li>be less verbose</li> <li>Uses Geometry() instead of point or polygon</li> <li>Improve performance of importing data by using pages</li> <li>Add threaded paging support for task_history table</li> <li>Refactor to import large datasets in pages and threading</li> <li>generate pngs for Markdown and PDFs from the .odt drawings</li> <li>Don't store pngs, they can be automatically generated</li> <li>Add threaded progress bars, paginate large postgres tables</li> <li>Add campaigns table, import the utility tables into this table</li> <li>Add messages config file</li> <li>Drop duplicate columns as this table is now nested in the tasks table</li> <li>Add task history and invalidation history as nested tables</li> <li>Implement a few tests for a sanity check</li> <li>Generate more test data for messages and campaigns</li> <li>Update after role enum changes</li> <li>pg.execute doesn't return anything</li> <li>Start implementing commands, now all generated SQL tables can get loaded into the database</li> <li>Minor tweaks to keep yamlint happy</li> <li>Make importing the primary table multi-threaded to improve performance</li> <li>Fix typo in type</li> <li>Make id a unique sequence variable</li> <li>Add array for managers</li> <li>Move team_members to it's own file</li> <li>Add enums for message types</li> <li>Add nested table definition</li> <li>Updated with more data</li> <li>Make importing data multi-threaded, it still takes a long time</li> <li>Add section on testing</li> <li>Add env variable for test database</li> <li>Add env variable to change the test database</li> <li>Add more API test case stubs</li> <li>Add more detail to reduce the pain of a new developer</li> <li>Add more content, update the intro section</li> <li>Add doc on the TM database schema as it exists now</li> <li>Add config file for campaigns</li> <li>Create team_members table for the users table</li> <li>Add support json as a data type, and nested tables</li> <li>Add tests for the featured column</li> <li>Implement methods for favorite projects</li> <li>Add method to remove an element from an array</li> <li>Add more project tests</li> <li>Add content on projects table</li> <li>Add more task related config files</li> <li>Add project_chat table</li> <li>Start on adding Task History support</li> <li>Add support for getting a single column, or updating an array</li> <li>Add target dump licenses and interests tables</li> <li>Add more test cases</li> <li>Add more tests</li> <li>Add 3 more columns from other tables</li> <li>Add support to merge the TM project_info data into the TM Admin projects table</li> <li>Add columns from the TM project_info table</li> <li>Make merging from user_licenses multi-threaded</li> <li>New config file for task_history table</li> <li>Regenerated after populating interests, licenses, and favorites with data from TM</li> <li>Import into testdata DB, not tm_admin</li> <li>Add more info on the user tables</li> <li>Add support to import from the TM4 user_licenses table into the licenses array in the tm_admin table</li> <li>Add support to merge the TM user_interests table into the tm_admin users table as an array</li> <li>Update tests after dbsupport changes</li> <li>Use row_to_json() in all queries</li> <li>Add target to import all .sql files into the test database</li> <li>Use testdata generated from postgres</li> <li>Handle required database columns not in the input source</li> <li>Move target to build test data files to tests from top level</li> <li>Add teams API tests</li> <li>Add more tests, add unimplemented debug to stubs</li> <li>Add stubs for all the TM internal APIs</li> <li>Add more tests from the TM backend</li> <li>Add data for test cases</li> <li>Comment out mapper_level for now</li> <li>Add join_method</li> <li>Fix logging</li> <li>Add more generated files</li> <li>Minor cleanup, no code changes</li> <li>Add check target to run pytests</li> <li>Get Entries here</li> <li>Add one more endpoint to the doc</li> <li>Don't get Entries in the constructor</li> <li>Minor changes to keep yamllint happy</li> <li>be less verbose</li> <li>If required, use '' instead of NULL</li> <li>Escape strings to remove embedded single quotes</li> <li>Handle zero length arrays</li> <li>Refactor creating the INSERT command, use the config file for datatypes</li> <li>Ad dminimal testcase for YAML config file parsing</li> <li>Refactor the YAML into a dict, instead of a list of lists</li> <li>Keep yamllint happy, adjust indents</li> <li>Import the TM projects table is starting to work, whew</li> <li>Add test case for organizations table</li> <li>Don't import UsersMessage</li> <li>Make userDB global to keep pytest happy</li> <li>Add more comments</li> <li>Add delete by ID</li> <li>Recursively scan for source files</li> <li>Add endpoints doc</li> <li>Add more API docs for the table classes</li> <li>Add more endpoints from TM admin</li> <li>Add wrappers for common SQL queries to the user table</li> <li>New test case for User table endpoint support</li> <li>Add column to tables for if supported by TM Admin</li> <li>Add draft of a doc on comparing endpoints between TM and FMTM</li> <li>Add comment about bugs in config file</li> <li>Add subscription_tier</li> <li>Import TM organisations table into TM Admin database</li> <li>for SQL, int64 generates a bigint</li> <li>Add a target to generate test date from TM</li> <li>New module for importing data from a Tasking Manager database into a TM Admin database</li> <li>Add more columns used by TM</li> <li>Convert int64 to bigint for SQL</li> <li>Some ID fileds are strings, not integers</li> <li>Add endpoints to receive data of profiles</li> <li>Make VALIDATOR unique</li> <li>Add methode to find a project or task by location</li> <li>Fix type in comment block</li> <li>fix module name</li> <li>Add more content in dataexchange page, add to index page</li> <li>Initial draft of a deep dive into exchaning data between multiple projects</li> <li>Minor typo repair</li> <li>Add dbsupport to API docs</li> <li>Add apidocs produced by doxygen</li> <li>Add protobuf API doc</li> <li>Use Markdown output instead of HTML so it works better with Github Pages</li> <li>Add doxygen support</li> <li>For docs target, also make the protobuf api docs</li> <li>Add links to tech deep dives</li> <li>Remove stupid comment</li> <li>Add more mkdocs comments</li> <li>Add more mkdocs comments</li> <li>Change the name of the output file for protobuf files</li> <li>Add mkdocs_protobuf plugin</li> <li>Use protoc-gen-docs to generate documentation for all the protobuf files</li> <li>Add mkdocs comment block</li> <li>Add mkdocs block comments</li> <li>aAdd more request types</li> <li>WHen converting Point or Polygon, it needs to stay upper case</li> <li>Comment out the other endpoints but request and notifications</li> <li>Use DBSupport as a base class</li> <li>Minor refactoring to support testing</li> <li>Refactor table classes to use a shared base class</li> <li>Update versions</li> <li>Updatw versions to the current one</li> <li>Comment out for now unimplemented optioms</li> <li>Improve logging setup</li> <li>Use new dbsupport class to avoid code duplication</li> <li>Use DBSupport for all methods</li> <li>Use lowercsase</li> <li>Use new dbsupport class to avoid code duplication</li> <li>Improve how logging works</li> <li>Add email to test case</li> <li>Use polygon or point instaed of public.geometry</li> <li>Use polygon or point instead of the whole public.geometry line</li> <li>Support for organizations tanble</li> <li>Add error for unimplemented requests</li> <li>Add more fields to the request and response messages</li> <li>Return single entry in list for query by ID or name to be comsistent</li> <li>Process request for user profile</li> <li>convert response to dict</li> <li>Include dict in protobuf response</li> <li>Use IntEnum instead of just Enum</li> <li>Only have one namespace, since it has to be shared between server and client</li> <li>Delete reuests.proto</li> <li>he type file has a _tm appended</li> <li>Build protobuf docs</li> <li>Add request and notification enums</li> <li>gRPC prefers a single top lecel service</li> <li>Exhchange messages</li> <li>Start workong with new data structures</li> <li>COnvert geometry to bytes</li> <li>Don't use package</li> <li>Add more generated files</li> <li>Close the file after writing it</li> <li>Add stubs for requests and datga exchange</li> <li>Add comments about modified enums used by TM, which was needed to avoid duplication</li> <li>For protobuf, all enum values must be unique globally</li> <li>Be less verbose</li> <li>Add more enum from TM statues file</li> <li>handle protobuf enums better</li> <li>Handle public enums better for protobuf files</li> <li>FIx indenting problems</li> <li>Add Mappinglevel enum that somehow got missed</li> <li>These don't work fully yet, just for development</li> <li>Start adding endpoints</li> <li>Drop the index page</li> <li>Fix a few typos</li> <li>Update CHANGELOG</li> <li>Fix typo in password settings</li> <li>Oops, add colon to tag</li> <li>Add more columns from TM</li> <li>Add section on the new unique keyword</li> <li>Add more content</li> <li>Add doc on the data flow, since there are a lot of generated files used elsewhere</li> <li>Add support for updating records, including the enums</li> <li>Add a unique contraint</li> <li>Add method to reset the sequence for id</li> <li>Query by ID name, or all rows, which is what TM needs</li> <li>update CHANGELOG</li> <li>Support class for managing the users table</li> <li>Make more items be shared in messages</li> <li>Handle datetime now</li> <li>Nre proto file for message requests</li> <li>Now generated classes use named parameters, which also get store in a dict</li> <li>Delete the new generated files</li> <li>Also generate the python stubs for data structures</li> <li>Create the tables in the database from the generated SQL files</li> <li>Update CHANGELOG</li> <li>Add actual content</li> <li>Add new files to API docs</li> <li>Major refactoring to use YAML config file for all file generation</li> <li>Major refactoring to use YAML config file for .sql generation</li> <li>Major refactoring to use YAML config file for .proto generation</li> <li>Add generated files to reduce clutter</li> <li>Refactoring to use yaml files for file generation completed</li> <li>Add organization section</li> <li>Add doc on the communication details</li> <li>Add initial content for a doc on data flow between projects</li> <li>Add default page</li> <li>Add doc on this project</li> <li>Add recursive targets, since tm_admin/Makefile does all the work</li> <li>Set version number to 0.1.0</li> <li>Start refactoring to use our messages</li> <li>Generate the SQL files from the YAML files</li> <li>add one sentence about python</li> <li>The SQL files now get generated from the YAML config files</li> <li>Drop SQL files, they're now generated from the yaml config files</li> <li>Add config file for organizxations table</li> <li>Add config file for tasks table</li> <li>Add config file for projects table</li> <li>Always generate types_tm.* files, improve handling of sequences</li> <li>Generate all the types_tm files</li> <li>Add config file for all typedefs and the user table</li> <li>Remove the generated type_tm.* files too</li> <li>Add new file documenting the yaml based config file syntax</li> <li>Generate SQL from yaml file</li> <li>Generate SQL and protobuf files from yaml config file</li> <li>Add method to convert a .proto file to a python dict</li> <li>update services to support user profiles</li> <li>Minimal implementation sending user profile data between client &amp; server</li> <li>Don't display the comments in the target</li> <li>Add config file and use it to specify host:port for the other programs</li> <li>Build the top level services stubs</li> <li>add grpc dependencies</li> <li>Improve table creation</li> <li>Update AGPL code block</li> <li>Move protobuf creation code to it's own file and use it</li> <li>Add realclean target to get rid of all non source files</li> <li>Use the protoc in grpc, not protobuf</li> <li>Add dependencies</li> <li>Add changelog file</li> <li>Add target to run Doxygen</li> <li>More files to create documentation infrastructure</li> <li>Add Doxyfile to generate API docs</li> <li>Update the License file</li> <li>Add more files</li> <li>Add the generated types* files too</li> <li>Add default docs</li> <li>Install the module</li> <li>sloppy merge for new code into a real git repo</li> </ul>"},{"location":"CHANGELOG/#refactor","title":"Refactor","text":"<ul> <li>rename tmadmin-manage --&gt; tmadmin_manage</li> </ul>"},{"location":"LICENSE/","title":"GNU AFFERO GENERAL PUBLIC LICENSE","text":"<p>Version 3, 19 November 2007</p> <p>Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/</p> <p>Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.</p>"},{"location":"LICENSE/#preamble","title":"Preamble","text":"<p>The GNU Affero General Public License is a free, copyleft license for software and other kinds of works, specifically designed to ensure cooperation with the community in the case of network server software.</p> <p>The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, our General Public Licenses are intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users.</p> <p>When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things.</p> <p>Developers that use our General Public Licenses protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License which gives you legal permission to copy, distribute and/or modify the software.</p> <p>A secondary benefit of defending all users' freedom is that improvements made in alternate versions of the program, if they receive widespread use, become available for other developers to incorporate. Many developers of free software are heartened and encouraged by the resulting cooperation. However, in the case of software used on network servers, this result may fail to come about. The GNU General Public License permits making a modified version and letting the public access it on a server without ever releasing its source code to the public.</p> <p>The GNU Affero General Public License is designed specifically to ensure that, in such cases, the modified source code becomes available to the community. It requires the operator of a network server to provide the source code of the modified version running there to the users of that server. Therefore, public use of a modified version, on a publicly accessible server, gives the public access to the source code of the modified version.</p> <p>An older license, called the Affero General Public License and published by Affero, was designed to accomplish similar goals. This is a different license, not a version of the Affero GPL, but Affero has released a new version of the Affero GPL which permits relicensing under this license.</p> <p>The precise terms and conditions for copying, distribution and modification follow.</p>"},{"location":"LICENSE/#terms-and-conditions","title":"TERMS AND CONDITIONS","text":""},{"location":"LICENSE/#0-definitions","title":"0. Definitions.","text":"<p>\"This License\" refers to version 3 of the GNU Affero General Public License.</p> <p>\"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks.</p> <p>\"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations.</p> <p>To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work.</p> <p>A \"covered work\" means either the unmodified Program or a work based on the Program.</p> <p>To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well.</p> <p>To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying.</p> <p>An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion.</p>"},{"location":"LICENSE/#1-source-code","title":"1. Source Code.","text":"<p>The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work.</p> <p>A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language.</p> <p>The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it.</p> <p>The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work.</p> <p>The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source.</p> <p>The Corresponding Source for a work in source code form is that same work.</p>"},{"location":"LICENSE/#2-basic-permissions","title":"2. Basic Permissions.","text":"<p>All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law.</p> <p>You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you.</p> <p>Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary.</p>"},{"location":"LICENSE/#3-protecting-users-legal-rights-from-anti-circumvention-law","title":"3. Protecting Users' Legal Rights From Anti-Circumvention Law.","text":"<p>No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures.</p> <p>When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures.</p>"},{"location":"LICENSE/#4-conveying-verbatim-copies","title":"4. Conveying Verbatim Copies.","text":"<p>You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program.</p> <p>You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee.</p>"},{"location":"LICENSE/#5-conveying-modified-source-versions","title":"5. Conveying Modified Source Versions.","text":"<p>You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions:</p> <ul> <li>a) The work must carry prominent notices stating that you modified     it, and giving a relevant date.</li> <li>b) The work must carry prominent notices stating that it is     released under this License and any conditions added under     section 7. This requirement modifies the requirement in section 4     to \"keep intact all notices\".</li> <li>c) You must license the entire work, as a whole, under this     License to anyone who comes into possession of a copy. This     License will therefore apply, along with any applicable section 7     additional terms, to the whole of the work, and all its parts,     regardless of how they are packaged. This License gives no     permission to license the work in any other way, but it does not     invalidate such permission if you have separately received it.</li> <li>d) If the work has interactive user interfaces, each must display     Appropriate Legal Notices; however, if the Program has interactive     interfaces that do not display Appropriate Legal Notices, your     work need not make them do so.</li> </ul> <p>A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate.</p>"},{"location":"LICENSE/#6-conveying-non-source-forms","title":"6. Conveying Non-Source Forms.","text":"<p>You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways:</p> <ul> <li>a) Convey the object code in, or embodied in, a physical product     (including a physical distribution medium), accompanied by the     Corresponding Source fixed on a durable physical medium     customarily used for software interchange.</li> <li>b) Convey the object code in, or embodied in, a physical product     (including a physical distribution medium), accompanied by a     written offer, valid for at least three years and valid for as     long as you offer spare parts or customer support for that product     model, to give anyone who possesses the object code either (1) a     copy of the Corresponding Source for all the software in the     product that is covered by this License, on a durable physical     medium customarily used for software interchange, for a price no     more than your reasonable cost of physically performing this     conveying of source, or (2) access to copy the Corresponding     Source from a network server at no charge.</li> <li>c) Convey individual copies of the object code with a copy of the     written offer to provide the Corresponding Source. This     alternative is allowed only occasionally and noncommercially, and     only if you received the object code with such an offer, in accord     with subsection 6b.</li> <li>d) Convey the object code by offering access from a designated     place (gratis or for a charge), and offer equivalent access to the     Corresponding Source in the same way through the same place at no     further charge. You need not require recipients to copy the     Corresponding Source along with the object code. If the place to     copy the object code is a network server, the Corresponding Source     may be on a different server (operated by you or a third party)     that supports equivalent copying facilities, provided you maintain     clear directions next to the object code saying where to find the     Corresponding Source. Regardless of what server hosts the     Corresponding Source, you remain obligated to ensure that it is     available for as long as needed to satisfy these requirements.</li> <li>e) Convey the object code using peer-to-peer transmission,     provided you inform other peers where the object code and     Corresponding Source of the work are being offered to the general     public at no charge under subsection 6d.</li> </ul> <p>A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work.</p> <p>A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product.</p> <p>\"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made.</p> <p>If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM).</p> <p>The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network.</p> <p>Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying.</p>"},{"location":"LICENSE/#7-additional-terms","title":"7. Additional Terms.","text":"<p>\"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions.</p> <p>When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission.</p> <p>Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms:</p> <ul> <li>a) Disclaiming warranty or limiting liability differently from the     terms of sections 15 and 16 of this License; or</li> <li>b) Requiring preservation of specified reasonable legal notices or     author attributions in that material or in the Appropriate Legal     Notices displayed by works containing it; or</li> <li>c) Prohibiting misrepresentation of the origin of that material,     or requiring that modified versions of such material be marked in     reasonable ways as different from the original version; or</li> <li>d) Limiting the use for publicity purposes of names of licensors     or authors of the material; or</li> <li>e) Declining to grant rights under trademark law for use of some     trade names, trademarks, or service marks; or</li> <li>f) Requiring indemnification of licensors and authors of that     material by anyone who conveys the material (or modified versions     of it) with contractual assumptions of liability to the recipient,     for any liability that these contractual assumptions directly     impose on those licensors and authors.</li> </ul> <p>All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying.</p> <p>If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms.</p> <p>Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way.</p>"},{"location":"LICENSE/#8-termination","title":"8. Termination.","text":"<p>You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11).</p> <p>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</p> <p>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</p> <p>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10.</p>"},{"location":"LICENSE/#9-acceptance-not-required-for-having-copies","title":"9. Acceptance Not Required for Having Copies.","text":"<p>You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so.</p>"},{"location":"LICENSE/#10-automatic-licensing-of-downstream-recipients","title":"10. Automatic Licensing of Downstream Recipients.","text":"<p>Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License.</p> <p>An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts.</p> <p>You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it.</p>"},{"location":"LICENSE/#11-patents","title":"11. Patents.","text":"<p>A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\".</p> <p>A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License.</p> <p>Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version.</p> <p>In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party.</p> <p>If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid.</p> <p>If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it.</p> <p>A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007.</p> <p>Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law.</p>"},{"location":"LICENSE/#12-no-surrender-of-others-freedom","title":"12. No Surrender of Others' Freedom.","text":"<p>If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program.</p>"},{"location":"LICENSE/#13-remote-network-interaction-use-with-the-gnu-general-public-license","title":"13. Remote Network Interaction; Use with the GNU General Public License.","text":"<p>Notwithstanding any other provision of this License, if you modify the Program, your modified version must prominently offer all users interacting with it remotely through a computer network (if your version supports such interaction) an opportunity to receive the Corresponding Source of your version by providing access to the Corresponding Source from a network server at no charge, through some standard or customary means of facilitating copying of software. This Corresponding Source shall include the Corresponding Source for any work covered by version 3 of the GNU General Public License that is incorporated pursuant to the following paragraph.</p> <p>Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the work with which it is combined will remain governed by version 3 of the GNU General Public License.</p>"},{"location":"LICENSE/#14-revised-versions-of-this-license","title":"14. Revised Versions of this License.","text":"<p>The Free Software Foundation may publish revised and/or new versions of the GNU Affero General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.</p> <p>Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU Affero General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU Affero General Public License, you may choose any version ever published by the Free Software Foundation.</p> <p>If the Program specifies that a proxy can decide which future versions of the GNU Affero General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program.</p> <p>Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version.</p>"},{"location":"LICENSE/#15-disclaimer-of-warranty","title":"15. Disclaimer of Warranty.","text":"<p>THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</p>"},{"location":"LICENSE/#16-limitation-of-liability","title":"16. Limitation of Liability.","text":"<p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>"},{"location":"LICENSE/#17-interpretation-of-sections-15-and-16","title":"17. Interpretation of Sections 15 and 16.","text":"<p>If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee.</p> <p>END OF TERMS AND CONDITIONS</p>"},{"location":"LICENSE/#how-to-apply-these-terms-to-your-new-programs","title":"How to Apply These Terms to Your New Programs","text":"<p>If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.</p> <p>To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found.</p> <pre><code>    &lt;one line to give the program's name and a brief idea of what it does.&gt;\n    Copyright (C) &lt;year&gt;  &lt;name of author&gt;\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as\n    published by the Free Software Foundation, either version 3 of the\n    License, or (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n</code></pre> <p>Also add information on how to contact you by electronic and paper mail.</p> <p>If your software can interact with users remotely through a computer network, you should also make sure that it provides a way for users to get its source. For example, if your program is a web application, its interface could display a \"Source\" link that leads users to an archive of the code. There are many ways you could offer source, and different solutions will be better for different programs; see section 13 for the specific requirements.</p> <p>You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU AGPL, see https://www.gnu.org/licenses/.</p>"},{"location":"about/","title":"TM-Admin","text":"<p>Administrative functions for Tasking Manager style projects. There is a lot of shared functionality between Tasking Manager style projects, so rather than having duplicate implementations, the goal of this project is to provide that functionality in a way it can be shared across multiple projects.</p> <p>These are implemented as python modules, and can be used in the backend of a Tasking Manager style website. While it is possible to have multiple projects access a single database, there is also support to exchange data between projects if they are all using their own database. There is more detail on the inter-project communication.</p>"},{"location":"about/#user-management","title":"User Management","text":"<p>Handles user profiles. While it is recommended, it is not required for all users to have an OSM ID. With an OSM ID, AUTH2 works, so users only have to login once, but can use multipe projects.</p>"},{"location":"about/#organization-management","title":"Organization Management","text":"<p>Handles organization profiles. Some organizations use multiple projects, so this just shares the profile data so it doesn't have to be entered multiple times.</p>"},{"location":"about/#project-management","title":"Project Management","text":"<p>Handles the project. A project in it's simplest form is an area of interest as a polygon, the name, the description, and a project manager. In addition it can access the tasks table for task specific data.</p>"},{"location":"about/#task-management","title":"Task Management","text":"<p>Handles the tasks. A task is a polygon within the project area of interest.</p>"},{"location":"about/#team-management","title":"Team Management","text":"<p>Handles OSM Teams profiles. </p>"},{"location":"api/","title":"API Docs for TM-Admin","text":""},{"location":"api/#tmadmin_managepy","title":"tmadmin_manage.py","text":""},{"location":"api/#dbsupportpy","title":"dbsupport.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/#tm_admin.dbsupport.DBSupport","title":"DBSupport","text":"<pre><code>DBSupport(table)\n</code></pre> <p>             Bases: <code>object</code></p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table to use for this connection.</p> required <p>Returns:</p> Type Description <code>DBSupport</code> <p>An instance of this class</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>def __init__(self,\n             table: str,\n            ):\n    \"\"\"\n    A base class since all tables have the same structure for queries.\n\n    Args:\n        table (str): The table to use for this connection.\n\n    Returns:\n        (DBSupport): An instance of this class\n    \"\"\"\n    self.pg = None\n    self.table = table\n    self.columns = None\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(dburi='localhost/tm_admin')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dburi</code> <code>str</code> <p>The URI string for the database connection.</p> <code>'localhost/tm_admin'</code> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def connect(self,\n                dburi: str = \"localhost/tm_admin\",\n                ):\n    \"\"\"\n    Args:\n        dburi (str): The URI string for the database connection.\n    \"\"\"\n    profile = f\"{self.table.capitalize()}Table()\"\n    self.profile = eval(profile)\n    if dburi:\n        self.pg = PostgresClient()\n        await self.pg.connect(dburi)\n    self.types = dir(tm_admin.types_tm)\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.createTable","title":"createTable  <code>async</code>","text":"<pre><code>createTable(obj)\n</code></pre> <p>Create a table in a postgres database.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <p>The config data for the table.</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def createTable(self,\n                obj,\n                ):\n    \"\"\"\n    Create a table in a postgres database.\n\n    Args:\n        obj: The config data for the table.\n    \"\"\"\n    sql = f\"INSERT INTO {self.table}(id, \"\n    for column,value in obj.data.items():\n        # print(f\"{column} is {type(value)}\")\n        if type(value) == str:\n            # FIXME: for now ignore timestamps, as they're meaningless\n            # between projects\n            try:\n                if parse(value):\n                    continue\n            except:\n                # it's a string, but not a date\n                pass\n        if value is not None:\n            sql += f\"{column},\"\n    sql = sql[:-1]\n    sql += f\") VALUES(\"\n    for column,value in obj.data.items():\n        try:\n            if parse(value):\n                continue\n        except:\n            pass\n        if column == 'id':\n            sql += f\"nextval('public.{self.table}_id_seq'),\"\n            continue\n        if value is None:\n            continue\n        elif type(value) == datetime:\n            continue\n        elif type(value) == int:\n            sql += f\"{value},\"\n        elif type(value) == bool:\n            if value:\n                sql += f\"true,\"\n            else:\n                sql += f\"false,\"\n        elif type(value) == str:\n            sql += f\"'{value}',\"\n\n    #print(sql[:-1])\n    result = await self.pg.execute(f\"{sql[:-1]});\")\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.updateTable","title":"updateTable  <code>async</code>","text":"<pre><code>updateTable(id=None)\n</code></pre> <p>Updates an existing table in the database</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the dataset to update</p> <code>None</code> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def updateTable(self,\n                id: int = None,\n                ):\n    \"\"\"\n    Updates an existing table in the database\n\n    Args:\n        id (int): The ID of the dataset to update\n    \"\"\"\n    sql = f\"UPDATE {self.table} SET\"\n    if not id:\n        id = profile.data['id']\n    for column,value in self.profile.data.items():\n        name = column.replace('_', '').capitalize()\n        if name in self.types:\n            # FIXME: this needs to not be hardcoded!\n            tmp = tm_admin.types_tm.Mappinglevel._member_names_\n            if type(value) == str:\n                level = value\n            else:\n                level = tmp[value-1]\n            sql += f\" {column}='{level}'\"\n            continue\n        if value:\n            try:\n                # FIXME: for now ignore timestamps, as they're meaningless\n                # between projects\n                if parse(value):\n                    continue\n            except:\n                # it's a string, but not a date\n                pass\n            sql += f\" {column}='{value}',\"\n    sql += f\" WHERE id='{id}'\"\n    # print(sql)\n    result = await self.pg.execute(f\"{sql[:-1]}';\")\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.resetSequence","title":"resetSequence  <code>async</code>","text":"<pre><code>resetSequence()\n</code></pre> <p>Reset the postgres sequence to zero.</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def resetSequence(self):\n    \"\"\"\n    Reset the postgres sequence to zero.\n    \"\"\"\n    sql = f\"ALTER SEQUENCE public.{self.table}_id_seq RESTART;\"\n    await self.pg.execute(sql)\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getByID","title":"getByID  <code>async</code>","text":"<pre><code>getByID(id)\n</code></pre> <p>Return the data for the ID in the table.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the dataset to retrieve.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The results of the query</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getByID(self,\n            id: int,\n            ):\n    \"\"\"\n    Return the data for the ID in the table.\n\n    Args:\n        id (int): The ID of the dataset to retrieve.\n\n    Returns:\n        (dict): The results of the query\n    \"\"\"\n\n    data = await self.getByWhere(f\" id={id}\")\n    if len(data) == 0:\n        return dict()\n    else:\n        return data[0][0]\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getByName","title":"getByName  <code>async</code>","text":"<pre><code>getByName(name)\n</code></pre> <p>Return the data for the name in the table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset to retrieve.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The results of the query</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getByName(self,\n            name: str,\n            ):\n    \"\"\"\n    Return the data for the name in the table.\n\n    Args:\n        name (str): The name of the dataset to retrieve.\n\n    Returns:\n        (list): The results of the query\n    \"\"\"\n    data = await self.getByWhere(f\" name='{name}'\")\n\n    if len(data) == 0:\n        return dict()\n    else:\n        return data[0][0]\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getAll","title":"getAll  <code>async</code>","text":"<pre><code>getAll()\n</code></pre> <p>Return all the data in the table.</p> <p>Returns:</p> Type Description <code>list</code> <p>The results of the query</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getAll(self):\n    \"\"\"\n    Return all the data in the table.\n\n    Returns:\n        (list): The results of the query\n    \"\"\"\n    sql = f\"SELECT row_to_json({self.table}) as row FROM {self.table}\"\n    # print(sql)\n    result = list()\n    result = await self.pg.execute(sql)\n\n    return result\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getByWhere","title":"getByWhere  <code>async</code>","text":"<pre><code>getByWhere(where)\n</code></pre> <p>Return the data for the where clause in the table.</p> <p>Parameters:</p> Name Type Description Default <code>where</code> <code>str</code> <p>The where clause of the dataset to retrieve.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The results of the query</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getByWhere(self,\n            where: str,\n            ):\n    \"\"\"\n    Return the data for the where clause in the table.\n\n    Args:\n        where (str): The where clause of the dataset to retrieve.\n\n    Returns:\n        (list): The results of the query\n    \"\"\"\n    sql = f\"SELECT row_to_json({self.table}) as row FROM {self.table} WHERE {where}\"\n    # print(sql)\n    result = await self.pg.execute(sql)\n\n    return result\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getByLocation","title":"getByLocation  <code>async</code>","text":"<pre><code>getByLocation(location, table='projects')\n</code></pre> <p>Return the database records in a table using GPS coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Point</code> <p>The location to use to find the project or task.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The results of the query</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getByLocation(self,\n            location: Point,\n            table: str = 'projects',\n            ):\n    \"\"\"\n    Return the database records in a table using GPS coordinates.\n\n    Args:\n        location (Point): The location to use to find the project or task.\n\n    Returns:\n        (list): The results of the query\n    \"\"\"\n    data = dict()\n    ewkt = shape(location)\n    sql = f\"SELECT row_to_json({self.table}) as row FROM {table} WHERE ST_CONTAINS(ST_GeomFromEWKT('SRID=4326;{ewkt}') geom)\"\n    result = await self.pg.execute(sql)\n\n    return result\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.deleteByID","title":"deleteByID  <code>async</code>","text":"<pre><code>deleteByID(id)\n</code></pre> <p>Delete the record for the ID in the table.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the dataset to delete.</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def deleteByID(self,\n            id: int,\n            ):\n    \"\"\"\n    Delete the record for the ID in the table.\n\n    Args:\n        id (int): The ID of the dataset to delete.\n    \"\"\"\n    sql = f\"DELETE FROM {self.table} WHERE id='{id}'\"\n    result = self.pg.execute(sql)\n    return True\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getColumn","title":"getColumn  <code>async</code>","text":"<pre><code>getColumn(uid, column)\n</code></pre> <p>This gets a single column from the database.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>int</code> <p>The ID to get</p> required <code>column</code> <code>str</code> <p>The column.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The column values</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getColumn(self,\n             uid: int,\n             column: str,\n             ):\n    \"\"\"\n    This gets a single column from the database.\n\n    Args:\n        uid (int): The ID to get\n        column (str): The column.\n\n    Returns:\n        (list): The column values\n    \"\"\"\n    sql = f\"SELECT {column} FROM {self.table} WHERE id={uid}\"\n    result = await self.pg.execute(sql)\n\n    if len(result) &gt; 0:\n        return result[0][column]\n    else:\n        return None\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.updateColumn","title":"updateColumn  <code>async</code>","text":"<pre><code>updateColumn(uid, data)\n</code></pre> <p>This updates a single column in the database. If you want to update multiple columns, use self.updateTable() instead.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>int</code> <p>The ID of the user to update</p> required <code>data</code> <code>dict</code> <p>The column and new value</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def updateColumn(self,\n                uid: int,\n                data: dict,\n                ):\n    \"\"\"\n    This updates a single column in the database. If you want to update multiple columns,\n    use self.updateTable() instead.\n\n    Args:\n        uid (int): The ID of the user to update\n        data (dict): The column and new value\n    \"\"\"\n    [[column, value]] = data.items()\n    sql = f\"UPDATE {self.table} SET {column}='{value}' WHERE id='{uid}'\"\n    # print(sql)\n    await self.pg.execute(f\"{sql};\")\n\n    return True\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.removeColumn","title":"removeColumn  <code>async</code>","text":"<pre><code>removeColumn(uid, data)\n</code></pre> <p>This updates a single array column in the database. If you want to update multiple columns, use self.updateTable() instead.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>int</code> <p>The ID of the user to update</p> required <code>data</code> <code>dict</code> <p>The column and new value</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def removeColumn(self,\n                uid: int,\n                data: dict,\n                ):\n    \"\"\"\n    This updates a single array column in the database.\n    If you want to update multiple columns, use self.updateTable()\n    instead.\n\n    Args:\n        uid (int): The ID of the user to update\n        data (dict): The column and new value\n    \"\"\"\n    [[column, value]] = data.items()\n    aval = \"'{\" + f\"{value}\" + \"}\"\n    sql = f\"UPDATE {self.table} SET {column}=array_remove({column}, {value}) WHERE id='{uid}'\"\n    # print(sql)\n    result = await self.pg.execute(f\"{sql};\")\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.appendColumn","title":"appendColumn  <code>async</code>","text":"<pre><code>appendColumn(uid, data)\n</code></pre> <p>This updates a single array column in the database. If you want to update multiple columns, use self.updateTable() instead.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>int</code> <p>The ID of the user to update</p> required <code>data</code> <code>dict</code> <p>The column and new value</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def appendColumn(self,\n                uid: int,\n                data: dict,\n                ):\n    \"\"\"\n    This updates a single array column in the database.\n    If you want to update multiple columns, use self.updateTable()\n    instead.\n\n    Args:\n        uid (int): The ID of the user to update\n        data (dict): The column and new value\n    \"\"\"\n    [[column, value]] = data.items()\n    aval = \"'{\" + f\"{value}\" + \"}\"\n    sql = f\"UPDATE {self.table} SET {column}={column}||{aval}' WHERE id='{uid}'\"\n    #print(sql)\n    result = await self.pg.execute(f\"{sql};\")\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.renameTable","title":"renameTable  <code>async</code>","text":"<pre><code>renameTable(table)\n</code></pre> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def renameTable(self,\n                    table: str,\n                    ):\n    \"\"\"\n    \"\"\"\n    sql = f\"DROP TABLE IF EXISTS {table}_bak\"\n    result = await self.pg.execute(sql)\n    sql = f\"ALTER TABLE {table} RENAME TO {table}_bak;\"\n    result = await self.pg.execute(sql)\n    sql = f\"ALTER TABLE new_{table} RENAME TO {table};\"\n    result = await self.pg.execute(sql)\n    sql = f\"DROP TABLE IF EXISTS {table}_bak CASCADE\"\n    result = await self.pg.execute(sql)\n\n    print(f\"renameTable{self.pg.dburi}\")\n    # These are copied for the TM4 database, but have been merged\n    # into the local database so JOIN works faster than remote\n    # access, or looping through tons of data in Python.\n    sql = f\"DROP TABLE IF EXISTS user_interests CASCADE\"\n    result = await self.pg.execute(sql)\n    sql = f\"DROP TABLE IF EXISTS user_licenses CASCADE\"\n    result = await self.pg.execute(sql)\n    sql = f\"DROP TABLE IF EXISTS team_members CASCADE\"\n    result = await self.pg.execute(sql)\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.copyTable","title":"copyTable  <code>async</code>","text":"<pre><code>copyTable(table, remote)\n</code></pre> <p>Use DBLINK to copy a table from the Tasking Manager database to a local table so JOINing is much faster.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table to copy</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def copyTable(self,\n                    table: str,\n                    remote: PostgresClient,\n                    ):\n    \"\"\"\n    Use DBLINK to copy a table from the Tasking Manager\n    database to a local table so JOINing is much faster.\n\n    Args:\n        table (str): The table to copy\n    \"\"\"\n    timer = Timer(initial_text=f\"Copying {table}...\",\n                  text=\"copying {table} took {seconds:.0f}s\",\n                  logger=log.debug,\n                )\n    # Get the columns from the remote database table\n    self.columns = await remote.getColumns(table)\n\n    print(f\"SELF: {self.pg.dburi}\")\n    print(f\"REMOTE: {remote.dburi}\")\n\n    # Do we already have a local copy ?\n    sql = f\"SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename  = '{table}'\"\n    result = await self.pg.execute(sql)\n    print(result)\n\n    # cleanup old temporary tables in the current database\n    # drop = [\"DROP TABLE IF EXISTS users_bak\",\n    #         \"DROP TABLE IF EXISTS user_interests\",\n    #         \"DROP TABLE IF EXISTS foo\"]\n    # result = await pg.pg.executemany(drop)\n    sql = f\"DROP TABLE IF EXISTS new_{table} CASCADE\"\n    result = await self.pg.execute(sql)\n    sql = f\"DROP TABLE IF EXISTS {table}_bak CASCADE\"\n    result = await self.pg.execute(sql)\n    timer.start()\n    dbuser = self.pg.dburi[\"dbuser\"]\n    dbpass = self.pg.dburi[\"dbpass\"]\n    sql = f\"CREATE SERVER IF NOT EXISTS pg_rep_db FOREIGN DATA WRAPPER dblink_fdw  OPTIONS (dbname 'tm4');\"\n    data = await self.pg.execute(sql)\n\n    sql = f\"CREATE USER MAPPING IF NOT EXISTS FOR {dbuser} SERVER pg_rep_db OPTIONS ( user '{dbuser}', password '{dbpass}');\"\n    result = await self.pg.execute(sql)\n\n    # Copy table from remote database so JOIN is faster when it's in the\n    # same database\n    #columns = await sel.getColumns(table)\n    log.warning(f\"Copying a remote table is slow, but faster than remote access......\")\n    sql = f\"SELECT * INTO {table} FROM dblink('pg_rep_db','SELECT * FROM {table}') AS {table}({self.columns})\"\n    print(sql)\n    result = await self.pg.execute(sql)\n\n    return True\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-u\", \"--uri\", default='localhost/tm_admin',\n                            help=\"Database URI\")\n    # parser.add_argument(\"-r\", \"--reset\", help=\"Reset Sequences\")\n    args = parser.parse_args()\n\n    # if len(argv) &lt;= 1:\n    #     parser.print_help()\n    #     quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    org = DBSupport('organizations')\n    await org.connect(args.uri)\n    # organization.resetSequence()\n    all = await org.getAll()\n\n    # Don't pass id, let postgres auto increment\n    ut = OrganizationsTable(name='test org', slug=\"slug\", type=1)\n#                            orgtype=tm_admin.types_tm.Organizationtype.FREE)\n    await org.createTable(ut)\n    # print(all)\n\n    all = await org.getByID(1)\n    print(all)\n\n    all = await org.getByName('fixme')\n    print(all)\n</code></pre>"},{"location":"api/#pgsupportpy","title":"pgsupport.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/#tm_admin.dbsupport.DBSupport","title":"DBSupport","text":"<pre><code>DBSupport(table)\n</code></pre> <p>             Bases: <code>object</code></p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table to use for this connection.</p> required <p>Returns:</p> Type Description <code>DBSupport</code> <p>An instance of this class</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>def __init__(self,\n             table: str,\n            ):\n    \"\"\"\n    A base class since all tables have the same structure for queries.\n\n    Args:\n        table (str): The table to use for this connection.\n\n    Returns:\n        (DBSupport): An instance of this class\n    \"\"\"\n    self.pg = None\n    self.table = table\n    self.columns = None\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(dburi='localhost/tm_admin')\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>dburi</code> <code>str</code> <p>The URI string for the database connection.</p> <code>'localhost/tm_admin'</code> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def connect(self,\n                dburi: str = \"localhost/tm_admin\",\n                ):\n    \"\"\"\n    Args:\n        dburi (str): The URI string for the database connection.\n    \"\"\"\n    profile = f\"{self.table.capitalize()}Table()\"\n    self.profile = eval(profile)\n    if dburi:\n        self.pg = PostgresClient()\n        await self.pg.connect(dburi)\n    self.types = dir(tm_admin.types_tm)\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.createTable","title":"createTable  <code>async</code>","text":"<pre><code>createTable(obj)\n</code></pre> <p>Create a table in a postgres database.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <p>The config data for the table.</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def createTable(self,\n                obj,\n                ):\n    \"\"\"\n    Create a table in a postgres database.\n\n    Args:\n        obj: The config data for the table.\n    \"\"\"\n    sql = f\"INSERT INTO {self.table}(id, \"\n    for column,value in obj.data.items():\n        # print(f\"{column} is {type(value)}\")\n        if type(value) == str:\n            # FIXME: for now ignore timestamps, as they're meaningless\n            # between projects\n            try:\n                if parse(value):\n                    continue\n            except:\n                # it's a string, but not a date\n                pass\n        if value is not None:\n            sql += f\"{column},\"\n    sql = sql[:-1]\n    sql += f\") VALUES(\"\n    for column,value in obj.data.items():\n        try:\n            if parse(value):\n                continue\n        except:\n            pass\n        if column == 'id':\n            sql += f\"nextval('public.{self.table}_id_seq'),\"\n            continue\n        if value is None:\n            continue\n        elif type(value) == datetime:\n            continue\n        elif type(value) == int:\n            sql += f\"{value},\"\n        elif type(value) == bool:\n            if value:\n                sql += f\"true,\"\n            else:\n                sql += f\"false,\"\n        elif type(value) == str:\n            sql += f\"'{value}',\"\n\n    #print(sql[:-1])\n    result = await self.pg.execute(f\"{sql[:-1]});\")\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.updateTable","title":"updateTable  <code>async</code>","text":"<pre><code>updateTable(id=None)\n</code></pre> <p>Updates an existing table in the database</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the dataset to update</p> <code>None</code> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def updateTable(self,\n                id: int = None,\n                ):\n    \"\"\"\n    Updates an existing table in the database\n\n    Args:\n        id (int): The ID of the dataset to update\n    \"\"\"\n    sql = f\"UPDATE {self.table} SET\"\n    if not id:\n        id = profile.data['id']\n    for column,value in self.profile.data.items():\n        name = column.replace('_', '').capitalize()\n        if name in self.types:\n            # FIXME: this needs to not be hardcoded!\n            tmp = tm_admin.types_tm.Mappinglevel._member_names_\n            if type(value) == str:\n                level = value\n            else:\n                level = tmp[value-1]\n            sql += f\" {column}='{level}'\"\n            continue\n        if value:\n            try:\n                # FIXME: for now ignore timestamps, as they're meaningless\n                # between projects\n                if parse(value):\n                    continue\n            except:\n                # it's a string, but not a date\n                pass\n            sql += f\" {column}='{value}',\"\n    sql += f\" WHERE id='{id}'\"\n    # print(sql)\n    result = await self.pg.execute(f\"{sql[:-1]}';\")\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.resetSequence","title":"resetSequence  <code>async</code>","text":"<pre><code>resetSequence()\n</code></pre> <p>Reset the postgres sequence to zero.</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def resetSequence(self):\n    \"\"\"\n    Reset the postgres sequence to zero.\n    \"\"\"\n    sql = f\"ALTER SEQUENCE public.{self.table}_id_seq RESTART;\"\n    await self.pg.execute(sql)\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getByID","title":"getByID  <code>async</code>","text":"<pre><code>getByID(id)\n</code></pre> <p>Return the data for the ID in the table.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the dataset to retrieve.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The results of the query</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getByID(self,\n            id: int,\n            ):\n    \"\"\"\n    Return the data for the ID in the table.\n\n    Args:\n        id (int): The ID of the dataset to retrieve.\n\n    Returns:\n        (dict): The results of the query\n    \"\"\"\n\n    data = await self.getByWhere(f\" id={id}\")\n    if len(data) == 0:\n        return dict()\n    else:\n        return data[0][0]\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getByName","title":"getByName  <code>async</code>","text":"<pre><code>getByName(name)\n</code></pre> <p>Return the data for the name in the table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the dataset to retrieve.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The results of the query</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getByName(self,\n            name: str,\n            ):\n    \"\"\"\n    Return the data for the name in the table.\n\n    Args:\n        name (str): The name of the dataset to retrieve.\n\n    Returns:\n        (list): The results of the query\n    \"\"\"\n    data = await self.getByWhere(f\" name='{name}'\")\n\n    if len(data) == 0:\n        return dict()\n    else:\n        return data[0][0]\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getAll","title":"getAll  <code>async</code>","text":"<pre><code>getAll()\n</code></pre> <p>Return all the data in the table.</p> <p>Returns:</p> Type Description <code>list</code> <p>The results of the query</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getAll(self):\n    \"\"\"\n    Return all the data in the table.\n\n    Returns:\n        (list): The results of the query\n    \"\"\"\n    sql = f\"SELECT row_to_json({self.table}) as row FROM {self.table}\"\n    # print(sql)\n    result = list()\n    result = await self.pg.execute(sql)\n\n    return result\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getByWhere","title":"getByWhere  <code>async</code>","text":"<pre><code>getByWhere(where)\n</code></pre> <p>Return the data for the where clause in the table.</p> <p>Parameters:</p> Name Type Description Default <code>where</code> <code>str</code> <p>The where clause of the dataset to retrieve.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The results of the query</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getByWhere(self,\n            where: str,\n            ):\n    \"\"\"\n    Return the data for the where clause in the table.\n\n    Args:\n        where (str): The where clause of the dataset to retrieve.\n\n    Returns:\n        (list): The results of the query\n    \"\"\"\n    sql = f\"SELECT row_to_json({self.table}) as row FROM {self.table} WHERE {where}\"\n    # print(sql)\n    result = await self.pg.execute(sql)\n\n    return result\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getByLocation","title":"getByLocation  <code>async</code>","text":"<pre><code>getByLocation(location, table='projects')\n</code></pre> <p>Return the database records in a table using GPS coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>Point</code> <p>The location to use to find the project or task.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The results of the query</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getByLocation(self,\n            location: Point,\n            table: str = 'projects',\n            ):\n    \"\"\"\n    Return the database records in a table using GPS coordinates.\n\n    Args:\n        location (Point): The location to use to find the project or task.\n\n    Returns:\n        (list): The results of the query\n    \"\"\"\n    data = dict()\n    ewkt = shape(location)\n    sql = f\"SELECT row_to_json({self.table}) as row FROM {table} WHERE ST_CONTAINS(ST_GeomFromEWKT('SRID=4326;{ewkt}') geom)\"\n    result = await self.pg.execute(sql)\n\n    return result\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.deleteByID","title":"deleteByID  <code>async</code>","text":"<pre><code>deleteByID(id)\n</code></pre> <p>Delete the record for the ID in the table.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The ID of the dataset to delete.</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def deleteByID(self,\n            id: int,\n            ):\n    \"\"\"\n    Delete the record for the ID in the table.\n\n    Args:\n        id (int): The ID of the dataset to delete.\n    \"\"\"\n    sql = f\"DELETE FROM {self.table} WHERE id='{id}'\"\n    result = self.pg.execute(sql)\n    return True\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.getColumn","title":"getColumn  <code>async</code>","text":"<pre><code>getColumn(uid, column)\n</code></pre> <p>This gets a single column from the database.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>int</code> <p>The ID to get</p> required <code>column</code> <code>str</code> <p>The column.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The column values</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def getColumn(self,\n             uid: int,\n             column: str,\n             ):\n    \"\"\"\n    This gets a single column from the database.\n\n    Args:\n        uid (int): The ID to get\n        column (str): The column.\n\n    Returns:\n        (list): The column values\n    \"\"\"\n    sql = f\"SELECT {column} FROM {self.table} WHERE id={uid}\"\n    result = await self.pg.execute(sql)\n\n    if len(result) &gt; 0:\n        return result[0][column]\n    else:\n        return None\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.updateColumn","title":"updateColumn  <code>async</code>","text":"<pre><code>updateColumn(uid, data)\n</code></pre> <p>This updates a single column in the database. If you want to update multiple columns, use self.updateTable() instead.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>int</code> <p>The ID of the user to update</p> required <code>data</code> <code>dict</code> <p>The column and new value</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def updateColumn(self,\n                uid: int,\n                data: dict,\n                ):\n    \"\"\"\n    This updates a single column in the database. If you want to update multiple columns,\n    use self.updateTable() instead.\n\n    Args:\n        uid (int): The ID of the user to update\n        data (dict): The column and new value\n    \"\"\"\n    [[column, value]] = data.items()\n    sql = f\"UPDATE {self.table} SET {column}='{value}' WHERE id='{uid}'\"\n    # print(sql)\n    await self.pg.execute(f\"{sql};\")\n\n    return True\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.removeColumn","title":"removeColumn  <code>async</code>","text":"<pre><code>removeColumn(uid, data)\n</code></pre> <p>This updates a single array column in the database. If you want to update multiple columns, use self.updateTable() instead.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>int</code> <p>The ID of the user to update</p> required <code>data</code> <code>dict</code> <p>The column and new value</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def removeColumn(self,\n                uid: int,\n                data: dict,\n                ):\n    \"\"\"\n    This updates a single array column in the database.\n    If you want to update multiple columns, use self.updateTable()\n    instead.\n\n    Args:\n        uid (int): The ID of the user to update\n        data (dict): The column and new value\n    \"\"\"\n    [[column, value]] = data.items()\n    aval = \"'{\" + f\"{value}\" + \"}\"\n    sql = f\"UPDATE {self.table} SET {column}=array_remove({column}, {value}) WHERE id='{uid}'\"\n    # print(sql)\n    result = await self.pg.execute(f\"{sql};\")\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.appendColumn","title":"appendColumn  <code>async</code>","text":"<pre><code>appendColumn(uid, data)\n</code></pre> <p>This updates a single array column in the database. If you want to update multiple columns, use self.updateTable() instead.</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>int</code> <p>The ID of the user to update</p> required <code>data</code> <code>dict</code> <p>The column and new value</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def appendColumn(self,\n                uid: int,\n                data: dict,\n                ):\n    \"\"\"\n    This updates a single array column in the database.\n    If you want to update multiple columns, use self.updateTable()\n    instead.\n\n    Args:\n        uid (int): The ID of the user to update\n        data (dict): The column and new value\n    \"\"\"\n    [[column, value]] = data.items()\n    aval = \"'{\" + f\"{value}\" + \"}\"\n    sql = f\"UPDATE {self.table} SET {column}={column}||{aval}' WHERE id='{uid}'\"\n    #print(sql)\n    result = await self.pg.execute(f\"{sql};\")\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.renameTable","title":"renameTable  <code>async</code>","text":"<pre><code>renameTable(table)\n</code></pre> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def renameTable(self,\n                    table: str,\n                    ):\n    \"\"\"\n    \"\"\"\n    sql = f\"DROP TABLE IF EXISTS {table}_bak\"\n    result = await self.pg.execute(sql)\n    sql = f\"ALTER TABLE {table} RENAME TO {table}_bak;\"\n    result = await self.pg.execute(sql)\n    sql = f\"ALTER TABLE new_{table} RENAME TO {table};\"\n    result = await self.pg.execute(sql)\n    sql = f\"DROP TABLE IF EXISTS {table}_bak CASCADE\"\n    result = await self.pg.execute(sql)\n\n    print(f\"renameTable{self.pg.dburi}\")\n    # These are copied for the TM4 database, but have been merged\n    # into the local database so JOIN works faster than remote\n    # access, or looping through tons of data in Python.\n    sql = f\"DROP TABLE IF EXISTS user_interests CASCADE\"\n    result = await self.pg.execute(sql)\n    sql = f\"DROP TABLE IF EXISTS user_licenses CASCADE\"\n    result = await self.pg.execute(sql)\n    sql = f\"DROP TABLE IF EXISTS team_members CASCADE\"\n    result = await self.pg.execute(sql)\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.DBSupport.copyTable","title":"copyTable  <code>async</code>","text":"<pre><code>copyTable(table, remote)\n</code></pre> <p>Use DBLINK to copy a table from the Tasking Manager database to a local table so JOINing is much faster.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>The table to copy</p> required Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def copyTable(self,\n                    table: str,\n                    remote: PostgresClient,\n                    ):\n    \"\"\"\n    Use DBLINK to copy a table from the Tasking Manager\n    database to a local table so JOINing is much faster.\n\n    Args:\n        table (str): The table to copy\n    \"\"\"\n    timer = Timer(initial_text=f\"Copying {table}...\",\n                  text=\"copying {table} took {seconds:.0f}s\",\n                  logger=log.debug,\n                )\n    # Get the columns from the remote database table\n    self.columns = await remote.getColumns(table)\n\n    print(f\"SELF: {self.pg.dburi}\")\n    print(f\"REMOTE: {remote.dburi}\")\n\n    # Do we already have a local copy ?\n    sql = f\"SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename  = '{table}'\"\n    result = await self.pg.execute(sql)\n    print(result)\n\n    # cleanup old temporary tables in the current database\n    # drop = [\"DROP TABLE IF EXISTS users_bak\",\n    #         \"DROP TABLE IF EXISTS user_interests\",\n    #         \"DROP TABLE IF EXISTS foo\"]\n    # result = await pg.pg.executemany(drop)\n    sql = f\"DROP TABLE IF EXISTS new_{table} CASCADE\"\n    result = await self.pg.execute(sql)\n    sql = f\"DROP TABLE IF EXISTS {table}_bak CASCADE\"\n    result = await self.pg.execute(sql)\n    timer.start()\n    dbuser = self.pg.dburi[\"dbuser\"]\n    dbpass = self.pg.dburi[\"dbpass\"]\n    sql = f\"CREATE SERVER IF NOT EXISTS pg_rep_db FOREIGN DATA WRAPPER dblink_fdw  OPTIONS (dbname 'tm4');\"\n    data = await self.pg.execute(sql)\n\n    sql = f\"CREATE USER MAPPING IF NOT EXISTS FOR {dbuser} SERVER pg_rep_db OPTIONS ( user '{dbuser}', password '{dbpass}');\"\n    result = await self.pg.execute(sql)\n\n    # Copy table from remote database so JOIN is faster when it's in the\n    # same database\n    #columns = await sel.getColumns(table)\n    log.warning(f\"Copying a remote table is slow, but faster than remote access......\")\n    sql = f\"SELECT * INTO {table} FROM dblink('pg_rep_db','SELECT * FROM {table}') AS {table}({self.columns})\"\n    print(sql)\n    result = await self.pg.execute(sql)\n\n    return True\n</code></pre>"},{"location":"api/#tm_admin.dbsupport.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/dbsupport.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-u\", \"--uri\", default='localhost/tm_admin',\n                            help=\"Database URI\")\n    # parser.add_argument(\"-r\", \"--reset\", help=\"Reset Sequences\")\n    args = parser.parse_args()\n\n    # if len(argv) &lt;= 1:\n    #     parser.print_help()\n    #     quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    org = DBSupport('organizations')\n    await org.connect(args.uri)\n    # organization.resetSequence()\n    all = await org.getAll()\n\n    # Don't pass id, let postgres auto increment\n    ut = OrganizationsTable(name='test org', slug=\"slug\", type=1)\n#                            orgtype=tm_admin.types_tm.Organizationtype.FREE)\n    await org.createTable(ut)\n    # print(all)\n\n    all = await org.getByID(1)\n    print(all)\n\n    all = await org.getByName('fixme')\n    print(all)\n</code></pre>"},{"location":"api/#generatorpy","title":"generator.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/#tm_admin.generator.Generator","title":"Generator","text":"<pre><code>Generator(filespec=None)\n</code></pre> <p>             Bases: <code>object</code></p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The config file to use as source.</p> <code>None</code> <p>Returns:</p> Type Description <code>Generator</code> <p>An instance of this class</p> Source code in <code>tm_admin/generator.py</code> <pre><code>def __init__(self,\n            filespec: str = None,\n            ):\n    \"\"\"\n    A class that generates the output files from the config data.\n\n    Args:\n        filespec (str): The config file to use as source.\n\n    Returns:\n        (Generator): An instance of this class\n    \"\"\"\n    self.filespec = None\n    self.yaml = None\n    if filespec:\n        self.filespec = Path(filespec)\n        self.yaml = YamlFile(filespec)\n    self.createTypes()\n    self.yaml2py = {'int32': 'int',\n                'int64': 'int',\n                'bool': 'bool',\n                'string': 'str',\n                'bytes': 'bytes',\n                'timestamp': 'timestamp without time zone',\n                'polygon': 'Polygon',\n                'point': 'Point',\n                'jsonb': 'dict',\n                }\n\n    self.yaml2sql = {'int32': 'int',\n                'int64': 'bigint',\n                'bool': 'bool',\n                'string': 'character varying',\n                'bytes': 'bytea',\n                'timestamp': 'timestamp without time zone',\n                'polygon': 'geometry(Polygon,4326)',\n                'point': 'geometry(Point,4326)',\n                'jsonb': 'jsonb',\n                }\n</code></pre>"},{"location":"api/#tm_admin.generator.Generator.readConfig","title":"readConfig","text":"<pre><code>readConfig(filespec)\n</code></pre> <p>Reads in the YAML config file.</p> <p>Parameters:</p> Name Type Description Default <code>filespec</code> <code>str</code> <p>The config file to use as source.</p> required Source code in <code>tm_admin/generator.py</code> <pre><code>def readConfig(self,\n                filespec: str,\n                ):\n    \"\"\"\n    Reads in the YAML config file.\n\n    Args:\n        filespec (str): The config file to use as source.\n    \"\"\"\n    self.filespec = Path(filespec)\n    self.yaml = YamlFile(filespec)\n</code></pre>"},{"location":"api/#tm_admin.generator.Generator.createTypes","title":"createTypes","text":"<pre><code>createTypes()\n</code></pre> <p>Creates the enum files, which need to be done first, since the other generated files reference these.</p> Source code in <code>tm_admin/generator.py</code> <pre><code>def createTypes(self):\n    \"\"\"\n    Creates the enum files, which need to be done first, since the\n    other generated files reference these.\n    \"\"\"\n    gen = self.readConfig(f'{rootdir}/types.yaml')\n    out = self.createSQLEnums()\n    with open('types_tm.sql', 'w') as file:\n        file.write(out)\n        file.close()\n    out = self.createProtoEnums()\n    with open('types_tm.proto', 'w') as file:\n        file.write(out)\n        file.close()\n    out = self.createPyEnums()\n    with open('types_tm.py', 'w') as file:\n        file.write(out)\n        file.close()\n</code></pre>"},{"location":"api/#tm_admin.generator.Generator.createSQLEnums","title":"createSQLEnums","text":"<pre><code>createSQLEnums()\n</code></pre> <p>Create an input file for postgres of the custom types.</p> <p>Returns:</p> Type Description <code>str</code> <p>The source for postgres to create the SQL types.</p> Source code in <code>tm_admin/generator.py</code> <pre><code>def createSQLEnums(self):\n    \"\"\"\n    Create an input file for postgres of the custom types.\n\n    Returns:\n        (str): The source for postgres to create the SQL types.\n    \"\"\"\n    out = \"\"\n    for entry in self.yaml.yaml:\n        [[table, values]] = entry.items()\n        out += f\"DROP TYPE IF EXISTS public.{table} CASCADE;\\n\"\n        out += f\"CREATE TYPE public.{table} AS ENUM (\\n\"\n        for line in values:\n            out += f\"\\t'{line}',\\n\"\n        out = out[:-2]\n        out += \"\\n);\\n\"\n    return out\n</code></pre>"},{"location":"api/#tm_admin.generator.Generator.createProtoEnums","title":"createProtoEnums","text":"<pre><code>createProtoEnums()\n</code></pre> <p>Create an input file for postgres of the custom types.</p> <p>Returns:</p> Type Description <code>str</code> <p>The source for protoc to create the Protobuf types.</p> Source code in <code>tm_admin/generator.py</code> <pre><code>def createProtoEnums(self):\n    \"\"\"\n    Create an input file for postgres of the custom types.\n\n    Returns:\n        (str): The source for protoc to create the Protobuf types.\n    \"\"\"\n    out = \"syntax = 'proto3';\\n\\n\"\n    for entry in self.yaml.yaml:\n        index = 0\n        [[table, values]] = entry.items()\n        out += f\"enum {table.capitalize()} {{\\n\"\n        for line in values:\n            out += f\"\\t{line} = {index};\\n\"\n            index += 1\n        out += \"};\\n\\n\"\n    return out\n</code></pre>"},{"location":"api/#tm_admin.generator.Generator.createPyEnums","title":"createPyEnums","text":"<pre><code>createPyEnums()\n</code></pre> <p>Create an input file for python of the custom types.</p> <p>Returns:</p> Type Description <code>str</code> <p>The source for python to create the enums.</p> Source code in <code>tm_admin/generator.py</code> <pre><code>def createPyEnums(self):\n    \"\"\"\n    Create an input file for python of the custom types.\n\n    Returns:\n        (str): The source for python to create the enums.\n    \"\"\"\n    out = f\"import logging\\n\"\n    out += f\"from enum import IntEnum\\n\"\n    for entry in self.yaml.yaml:\n        index = 1\n        [[table, values]] = entry.items()\n        out += f\"class {table.capitalize()}(IntEnum):\\n\"\n        for line in values:\n            out += f\"\\t{line} = {index}\\n\"\n            index += 1\n        out += '\\n'\n    return out\n</code></pre>"},{"location":"api/#tm_admin.generator.Generator.createPyMessage","title":"createPyMessage","text":"<pre><code>createPyMessage()\n</code></pre> <p>Creates a python class wrapper for protobuf.</p> <p>Returns:</p> Type Description <code>str</code> <p>The source for python to create the class stubs.</p> Source code in <code>tm_admin/generator.py</code> <pre><code>    def createPyMessage(self):\n        \"\"\"\n        Creates a python class wrapper for protobuf.\n\n        Returns:\n            (str): The source for python to create the class stubs.\n        \"\"\"\n        out = f\"\"\"\nimport logging\nfrom datetime import timedelta\n# from shapely.geometry import Polygon, Point, shape\n\nlog = logging.getLogger(__name__)\n        \"\"\"\n        for entry in self.yaml.yaml:\n            [[table, settings]] = entry.items()\n            out += f\"\"\"\nclass {table.capitalize()}Message(object):\n    def __init__(self, \n            \"\"\"\n            # print(table, settings)\n            share = False\n            datatype = None\n            data = \"        self.data = {\"\n            for item in settings:\n                if type(item) == dict:\n                    [[k, v]] = item.items()\n                    # print(v)\n                    if v == \"jsonb\":\n                        datatype = \"dict\"\n                        breakpoint()\n                    for k1 in v:\n                        if type(k1) == dict:\n                            [[k2, v2]] = k1.items()\n                            if k2 == 'share' and v2:\n                                share = True\n                        elif type(k1) == str:\n                            if k1 in self.yaml2py:\n                                datatype = self.yaml2py[k1]\n                            else:\n                                datatype = item\n                                continue\n                    if share:\n                        share = False\n                        out += f\"{k}: {datatype} = None, \"\n                        data += f\"'{k}': {k}, \"\n        out += \"):\\n\"\n        out += f\"{data[:-2]}}}\\n\"\n\n        return out\n</code></pre>"},{"location":"api/#tm_admin.generator.Generator.createPyClass","title":"createPyClass","text":"<pre><code>createPyClass()\n</code></pre> <p>Creates a python class wrapper for the protobuf messages.</p> <p>Returns:</p> Type Description <code>str</code> <p>The source for python to create the class stubs.</p> Source code in <code>tm_admin/generator.py</code> <pre><code>    def createPyClass(self):\n        \"\"\"\n        Creates a python class wrapper for the protobuf messages.\n\n        Returns:\n            (str): The source for python to create the class stubs.\n        \"\"\"\n        out = f\"\"\"\nimport logging\nfrom datetime import datetime\nimport tm_admin.types_tm\nfrom shapely.geometry import Point, LineString, Polygon\n\nlog = logging.getLogger(__name__)\n\n        \"\"\"\n        for entry in self.yaml.yaml:\n            [[table, settings]] = entry.items()\n            out += f\"\"\"\nclass {table.capitalize()}Table(object):\n    def __init__(self, \n            \"\"\"\n            datatype = None\n            now = datetime.now()\n            data = \"            self.data = {\"\n            for item in settings:\n                if type(item) == dict:\n                    [[k, v]] = item.items()\n                    for k1 in v:\n                        if type(k1) == dict:\n                            continue\n                        elif type(k1) == str:\n                            if k1[:15] == 'public.geometry':\n                                datatype = k1[16:-1].split(',')[0]\n                                log.warning(f\"GEOMETRY: {datatype}\")\n                            elif k1[:7] == 'public.':\n                                # FIXME: It's in the SQL types\n                                datatype = f\"tm_admin.types_tm.{k1[7:].capitalize()}\"\n                                # log.warning(f\"SQL ENUM {k1}! {datatype}\")\n                            elif k1 in self.yaml2py:\n                                datatype = self.yaml2py[k1]\n                            else:\n                                datatype = item\n                                continue\n                        if k1 == 'bool':\n                            out += f\"{k}: {datatype} = False, \"\n                        elif k1 == 'timestamp':\n                            out += f\"{k}: datetime = '{datetime.now()}', \"\n                        elif k1[:7] == 'public.':\n                            defined = f\"tm_admin.types_tm.{k1[7:].capitalize()}\"\n                            # log.warning(f\"SQL ENUM {k1}!!\")\n                            default = eval(f\"{defined}(1)\")\n                            out += f\"{k}: {defined} =  {defined}.{default.name}, \"\n                            # out += f\"{k}: int =  1, \"\n                        else:\n                            out += f\"{k}: {datatype} = None, \"\n                        # print(k)\n                        data += f\"'{k}': {k}, \"\n            out = out[:-2]\n            out += \"):\\n\"\n            out += f\"{data[:-2]}}}\\n\"\n\n        return out\n</code></pre>"},{"location":"api/#tm_admin.generator.Generator.createProtoMessage","title":"createProtoMessage","text":"<pre><code>createProtoMessage()\n</code></pre> <p>Create the source for a protobuf message</p> <p>Returns:</p> Type Description <code>list</code> <p>The protobuf message source.</p> Source code in <code>tm_admin/generator.py</code> <pre><code>def createProtoMessage(self):\n    \"\"\"\n    Create the source for a protobuf message\n\n    Returns:\n        (list): The protobuf message source.\n    \"\"\"\n    pb = ProtoBuf()\n    out = pb.createTableProto(self.yaml.yaml)\n    return out\n</code></pre>"},{"location":"api/#tm_admin.generator.Generator.createSQLTable","title":"createSQLTable","text":"<pre><code>createSQLTable()\n</code></pre> <p>Create the source for an SQL table.</p> <p>Returns:</p> Type Description <code>str</code> <p>The protobuf message source.</p> Source code in <code>tm_admin/generator.py</code> <pre><code>    def createSQLTable(self):\n        \"\"\"\n        Create the source for an SQL table.\n\n        Returns:\n            (str): The protobuf message source.\n        \"\"\"\n        out = \"-- Do not edit this file, it's generated from the yaml file\\n\\n\"\n        sequence = list()\n        primary = list()\n        partition = list()\n        for entry in self.yaml.yaml:\n            [[table, values]] = entry.items()\n            out += f\"DROP TABLE IF EXISTS public.{table} CASCADE;\\n\"\n            out += f\"CREATE TABLE public.{table} (\\n\"\n            unique = list()\n            typedef = \"\"\n            for line in values:\n                # these are usually from the types.yaml file, which have no\n                # settings beyond the enum value.\n                if type(line) == str:\n                    # print(f\"SQL TABLE: {typedef} {line}\")\n                    typedef = table\n                    continue\n                [[k, v]] = line.items()\n                required = \"\"\n                array = \"\"\n                public = False\n                primary = list()\n                partition = list()\n                for item in v:\n                    if type(item) == dict:\n                        if 'sequence' in item and item['sequence']:\n                            sequence.append(k)\n                        if 'required' in item and item['required']:\n                            required = ' NOT NULL'\n                        if 'array' in item and item['array']:\n                            array = \"[]\"\n                        if 'unique' in item and item['unique']:\n                            unique.append(k)\n                        if 'primary' in item and item['primary']:\n                            primary.append(k)\n                        if 'partition' in item and item['partition']:\n                            partition.append(k)\n                    if len(v) &gt;= 2:\n                        if 'required' in v[1] and v[1]['required']:\n                            required = ' NOT NULL'\n                    if type(item) == str:\n                        if item[:7] == 'public.' and item[15:8] != 'geometry':\n                            public = True\n                        # elif item[15:8] == 'geometry':\n                        #     out += f\"\\t{k} {self.yaml2py[v[0]]}{array}{required},\\n\"\n                if public:\n                    out += f\"\\t{k} {v[0]}{array}{required},\\n\"\n                else:\n                    # print(v)\n                    # FIXME: if this produces an error, check the yaml file as this\n                    # usually means the type field isn't first in the list.\n                    if v[0][:6] == 'table.':\n                        out += f\"\\t{k} {v[0][6:]}{array},\\n\"\n                    else:\n                        try:\n                            out += f\"\\t{k} {self.yaml2sql[v[0]]}{array}{required},\\n\"\n                        except:\n                            breakpoint()\n            if len(unique) &gt; 0:\n                keys = str(unique).replace(\"'\", \"\")[1:-1];\n                out += f\"\\tUNIQUE({keys})\\n);\\n\"\n            if out[-2:] == ',\\n':\n                out = f\"{out[:-2]}\\n);\\n\\n\"\n            if len(sequence) &gt; 0:\n                for key in sequence:\n                    out += f\"\"\"\nDROP SEQUENCE IF EXISTS public.{table}_{key}_seq CASCADE;\nCREATE SEQUENCE public.{table}_{key}_seq\n        START WITH 1\n        INCREMENT BY 1\n        NO MINVALUE\n        NO MAXVALUE\n        CACHE 1;\n\n\"\"\"\n        if len(primary) &gt; 0:\n            keys = str(primary).replace(\"'\", \"\")[1:-1];\n            out += f\"\\tALTER TABLE {table} ADD CONSTRAINT {table}_pkey PRIMARY KEY({keys})\\n);\\n\"\n\n        return out + \"\\n\"\n</code></pre>"},{"location":"api/#tm_admin.generator.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/generator.py</code> <pre><code>def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"generator\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"Generate SQL, Protobuf, and Python data structures\",\n        epilog=\"\"\"\n        This should only be run standalone for debugging purposes.\n        \"\"\",\n    )\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    args, known = parser.parse_known_args()\n\n    if len(argv) &lt;= 1:\n        parser.print_help()\n        quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    gen = Generator()\n    for config in known:\n        gen.readConfig(config)\n        out = gen.createSQLTable()\n        sqlfile = config.replace('.yaml', '.sql')\n        path = Path(sqlfile)\n        #if path.exists():\n        #    path.rename(file.replace('.sql', '_bak.sql'))\n        with open(sqlfile, 'w') as file:\n            file.write(out)\n            log.info(f\"Wrote {sqlfile} to disk\")\n            file.close()\n        proto = config.replace('.yaml', '.proto')\n        # out = gen.createProtoMessage()\n        # with open(proto, 'w') as file:\n        #     file.writelines([str(i)+'\\n' for i in out])\n        #     log.info(f\"Wrote {proto} to disk\")\n        #     file.close()\n\n        print(config)\n        out = gen.createPyClass()\n        py = config.replace('.yaml', '_class.py')\n        with open(py, 'w') as file:\n            file.write(out)\n            log.info(f\"Wrote {py} to disk\")\n            file.close()\n        # print(out)\n        out = gen.createPyMessage()\n        py = config.replace('.yaml', '_proto.py')\n        with open(py, 'w') as file:\n            file.write(out)\n            log.info(f\"Wrote {py} to disk\")\n            file.close()\n</code></pre>"},{"location":"api/#protopy","title":"proto.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/#tm_admin.proto.ProtoBuf","title":"ProtoBuf","text":"<pre><code>ProtoBuf(sqlfile=None)\n</code></pre> <p>             Bases: <code>object</code></p> <p>Returns:</p> Type Description <code>ProtoBuf</code> <p>An instance of this class</p> Source code in <code>tm_admin/proto.py</code> <pre><code>def __init__(self,\n            sqlfile: str = None,\n            ):\n    \"\"\"\n    A class that generates protobuf files from the config data.\n\n    Returns:\n        (ProtoBuf): An instance of this class\n    \"\"\"\n    self.sqlfile = sqlfile\n</code></pre>"},{"location":"api/#tm_admin.proto.ProtoBuf.createEnumProto","title":"createEnumProto","text":"<pre><code>createEnumProto(enums)\n</code></pre> <p>Process a list of enums into the protobuf version.</p> <p>Parameters:</p> Name Type Description Default <code>enums</code> <code>dict</code> <p>The list of tables to generate a protobuf for.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The list of enums in protobuf format</p> Source code in <code>tm_admin/proto.py</code> <pre><code>def createEnumProto(self,\n                enums: dict,\n                ):\n    \"\"\"\n    Process a list of enums into the protobuf version.\n\n    Args:\n        enums (dict): The list of tables to generate a protobuf for.\n\n    Returns:\n        (list): The list of enums in protobuf format\n    \"\"\"\n    out = list()\n    out.append(f\"syntax = 'proto3';\")\n    for name, value in enums.items():\n        index = 0\n        out.append(f\"enum {name.capitalize()} {{\")\n        for entry in value:\n            out.append(f\"\\t{entry} = {index};\")\n            index += 1\n        out.append('};')\n\n    return out\n</code></pre>"},{"location":"api/#tm_admin.proto.ProtoBuf.createTableProto","title":"createTableProto","text":"<pre><code>createTableProto(tables)\n</code></pre> <p>Process a list of tables into the protobuf version.</p> <p>Parameters:</p> Name Type Description Default <code>tables</code> <code>list</code> <p>The list of tables to generate a protobuf for.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The list of tables in protobuf format</p> Source code in <code>tm_admin/proto.py</code> <pre><code>def createTableProto(self,\n                tables: list,\n                ):\n    \"\"\"\n    Process a list of tables into the protobuf version.\n\n    Args:\n        tables (list): The list of tables to generate a protobuf for.\n\n    Returns:\n        (list): The list of tables in protobuf format\n    \"\"\"\n    out = list()\n    out.append(f\"syntax = 'proto3';\")\n    # types.proto is generated from the types.yaml file.\n    # out.append(\"import 'types_tm.proto';\")\n    out.append(\"package tmadmin;\")\n    out.append(\"import 'types_tm.proto';\")\n    out.append(\"import 'google/protobuf/timestamp.proto';\")\n\n    convert = {'timestamp': \"google.protobuf.Timestamp\",\n               'polygon': 'bytes', 'point': 'bytes'}\n    for table in tables:\n        index = 1\n        for key, value in table.items():\n            out.append(f\"message {key} {{\")\n            optional = \"\"\n            repeated = \"\"\n            # print(f\"VALUE: {value}\")\n            for data in value:\n                #if type(data) == str:\n                #    log.warning(f\"ENUM: {data}\")\n                #    continue\n                for entry, settings in data.items():\n                    # print(f\"DATA: {entry} = {settings}\")\n                    #    datatype = settings[0][7:].capitalize()\n                    share = False\n                    array = \"\"\n                    datatype = None\n                    required = \"\"\n                    optional = \"\"\n                    for item in settings:\n                        if type(item) == str:\n                            # print(f\"DATA: {item}\")\n                            if item[:15] == 'public.geometry':\n                                datatype = \"bytes\"\n                            elif item[:7] == 'public.':\n                                datatype = item[7:].capitalize()\n                            elif item in convert:\n                                datatype = convert[item]\n                            else:\n                                datatype = item\n                            continue\n                        if type(item) == dict:\n                            [[k, v]] = item.items()\n                            if k == 'required' and v:\n                                required = k\n                            if k == 'optional' and v:\n                                optional = k\n                            if k == 'share':\n                                share = True\n                            if k == 'array':\n                                array = \"repeated\"\n                    if not share:\n                        continue\n                    # out.append(f\"\\t{required} {optional} {datatype} {entry} = {index};\")\n                    out.append(f\"\\t {array} {optional} {datatype} {entry} = {index};\")\n                    index += 1\n        out.append(f\"}}\")\n\n    return out\n</code></pre>"},{"location":"api/#tm_admin.proto.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/proto.py</code> <pre><code>def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"config\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"Manage the postgres database for the tm-admin project\",\n        epilog=\"\"\"\n        This should only be run standalone for debugging purposes.\n        \"\"\",\n    )\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    args, known = parser.parse_known_args()\n\n    if len(argv) &lt;= 1:\n        parser.print_help()\n        # quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    tm = ProtoBuf()\n    for table in known:\n        out1, out2 = tm.createProtoFromSQL(table)\n        name = table.replace('.sql', '.proto')\n        # pyfile = table.replace('.sql', '.py')\n        # xx = tm.protoToDict(name)\n        # name = table.replace('.yaml', '.proto')\n        out = tm.createTableProto()\n        if len(out1) &gt; 0:\n            with open(name, 'w') as file:\n                file.writelines([str(i)+'\\n' for i in out1])\n                file.close()\n        if len(out2) &gt; 0:\n            with open(name, 'w') as file:\n                file.writelines([str(i)+'\\n' for i in out2])\n                file.close()\n        log.info(f\"Wrote {name} to disk\")\n</code></pre>"},{"location":"api/#tmserverpy","title":"tmserver.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/#tm_admin.tmserver.TMServer","title":"TMServer","text":"<pre><code>TMServer(target)\n</code></pre> <p>             Bases: <code>object</code></p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The name of the target program</p> required <p>Returns:</p> Type Description <code>TMServer</code> <p>An instance of this class</p> Source code in <code>tm_admin/tmserver.py</code> <pre><code>def __init__(self,\n             target: str,\n             ):\n    \"\"\"\n    Instantiate a server\n\n    Args:\n        target (str): The name of the target program\n\n    Returns:\n        (TMServer): An instance of this class\n    \"\"\"\n    self.hosts = YamlFile(f\"{rootdir}/services.yaml\")\n    log.debug(\"Starting server\")\n    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))\n    tm_admin.services_pb2_grpc.add_TMAdminServicer_to_server(\n        RequestServicer(), server\n    )\n    # Enable reflection for grpc_cli\n    SERVICE_NAMES = (\n        tm_admin.services_pb2.DESCRIPTOR.services_by_name['TMAdmin'].full_name,\n        reflection.SERVICE_NAME,\n    )\n    reflection.enable_server_reflection(SERVICE_NAMES, server)\n\n    target = self.getTarget(target)\n    [[host, port]] = target.items()\n    # FIXME: this needs to use SSL for a secure connection\n    server.add_insecure_port(f\"[::]:{port}\")\n    server.start()\n    server.wait_for_termination()\n</code></pre>"},{"location":"api/#tm_admin.tmserver.TMServer.getTarget","title":"getTarget","text":"<pre><code>getTarget(target)\n</code></pre> <p>Get the target hostname and IP port number</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The name of the target program</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the hostname and IP port for this target program</p> Source code in <code>tm_admin/tmserver.py</code> <pre><code>def getTarget(self,\n            target: str,\n            ):\n    \"\"\"\n    Get the target hostname and IP port number\n\n    Args:\n        target (str): The name of the target program\n\n    Returns:\n        (dict): the hostname and IP port for this target program\n    \"\"\"\n    return self.hosts.yaml[0][target][0]\n</code></pre>"},{"location":"api/#tm_admin.tmserver.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/tmserver.py</code> <pre><code>def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"tmserver\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"Server for gRPC communication\",\n        epilog=\"\"\"\n        This should only be run standalone for debugging purposes.\n        \"\"\",\n    )\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n\n    args = parser.parse_args()\n\n    # if len(argv) &lt;= 1:\n    #     parser.print_help()\n    #     quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    # This blocks till  this process is killed\n    tm = TMServer('test')\n</code></pre>"},{"location":"api/#tmclientpy","title":"tmclient.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/#tm_admin.tmclient.TMClient","title":"TMClient","text":"<pre><code>TMClient(target)\n</code></pre> <p>             Bases: <code>object</code></p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The name of the target program</p> required <p>Returns:</p> Type Description <code>TMClient</code> <p>An instance of this class</p> Source code in <code>tm_admin/tmclient.py</code> <pre><code>def __init__(self,\n            target: str,\n            ):\n    \"\"\"\n    Instantiate a client\n\n    Args:\n        target (str): The name of the target program\n\n    Returns:\n        (TMClient): An instance of this class\n    \"\"\"\n    # the services.yaml file defines the hostname and ports for all programs.\n    self.hosts = YamlFile(f\"{rootdir}/services.yaml\")\n    target = self.getTarget(target)\n    [[host, port]] = target.items()\n    # FIXME: this needs to use SSL for a secure connection\n    self.channel = grpc.insecure_channel(f\"{host}:{port}\")\n    # self.stub = tm_admin.services_pb2_grpc.TMClientStub(channel)\n    # self.stub = tm_admin.services_pb2_grpc.testStub(self.channel)\n    self.stub = tm_admin.services_pb2_grpc.TMAdminStub(self.channel)\n</code></pre>"},{"location":"api/#tm_admin.tmclient.TMClient.sendUserProfile","title":"sendUserProfile","text":"<pre><code>sendUserProfile(msg)\n</code></pre> <p>Send data to the target program</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to send</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The response from the server</p> Source code in <code>tm_admin/tmclient.py</code> <pre><code>def sendUserProfile(self,\n            msg: str,\n            ):\n    \"\"\"\n    Send data to the target program\n\n    Args:\n        msg (str): The message to send\n\n    Returns:\n       (dict): The response from the server\n    \"\"\"\n    foo = UsersMessage(id=1, username=msg, name=msg)\n\n    bar = serialize_to_protobuf(foo.data, tm_admin.users.users_pb2.users)\n\n    response = self.stub.GetUser(bar)\n    #print(f\"TMAdmin client received: {response}\")\n    return response\n</code></pre>"},{"location":"api/#tm_admin.tmclient.TMClient.getTarget","title":"getTarget","text":"<pre><code>getTarget(target)\n</code></pre> <p>Get the target hostname and IP port number</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The name of the target program</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the hostname and IP port for this target program</p> Source code in <code>tm_admin/tmclient.py</code> <pre><code>def getTarget(self,\n            target: str,\n            ):\n    \"\"\"\n    Get the target hostname and IP port number\n\n    Args:\n        target (str): The name of the target program\n\n    Returns:\n        (dict): the hostname and IP port for this target program\n    \"\"\"\n    return self.hosts.yaml[0][target][0]\n</code></pre>"},{"location":"api/#tm_admin.tmclient.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/tmclient.py</code> <pre><code>def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"tmclient\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"gRPC Client\",\n        epilog=\"\"\"\n        This should only be run standalone for debugging purposes.\n        \"\"\",\n    )\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-m\", \"--msg\", default='who', help=\"string to send\")\n    args, known = parser.parse_known_args()\n\n    # if len(argv) &lt;= 1:\n    #     parser.print_help()\n    #     quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    tm = TMClient('test')\n\n    cmd = {'cmd': Command.GET_USER, 'id': 2}\n    response = tm.sendRequest(cmd)\n    print(f\"TMAdmin user received: {response}\")\n\n    cmd = {'cmd': Command.GET_TEAM, 'id': 20}\n    response = tm.sendRequest(cmd)\n    print(f\"TMAdmin team received: {response}\")\n\n    cmd = {'cmd': Command.GET_ORG, 'id': 10}\n    response = tm.sendRequest(cmd)\n    print(f\"TMAdmin organization received: {response}\")\n</code></pre>"},{"location":"build/","title":"Building TM-Admin","text":"<p>This is a complicated project as it involves parsing and outputting multiple file formats. This project uses gRPC for the low-level communication layer, which is below the REST API. This way it can be used by multiple other project REST APIs for exchanging data without massive refactoring of an existing API.</p> <p>The database schema is based on the ones in use in the FMTM project, which were originally based on the ones used by the HOT Tasking Manager. The schemas have years of improvements on the data requirements of Tasking Manager style projects. Not every column in a database table will be needed by each project, they can be ignored. It should be entirely possible to use a custom configuration file, but this is currently unsupported. (would love a patch for this)</p> <p>This project generates multiple files at runtime, so each is organized into a sub-directory, one for each table. The program that processes each configuration file is generator.py, which is part of this project. This reads in a configuration file in YAML format, and generates the output files for this configuration file. There is also a class Generator that can be used by other projects.</p> <p>These are the current modules supported by this project.</p> <ul> <li>users</li> <li>projects</li> <li>tasks</li> <li>organizations</li> <li>teams</li> </ul>"},{"location":"build/#tmadmin-manage","title":"tmadmin-manage","text":"<p>The tmadmin-manage program is for higher-level data management. While each class can be run standalone, that's more for testing &amp; development. This program is also both a standalone program, and a class that can be used by other projects. This program will create the database and tables for each module.</p>"},{"location":"build/#datatypes","title":"Datatypes","text":"<p>Each database table has it's own configuration file. There is also a top level one, types.yaml that generates the type definitions that all the other files depend on. This becomes types_tm.sql, types_tm.proto, and types_tm.py, and needs to be imported before the other files.</p>"},{"location":"build/#yaml-files","title":".yaml files","text":"<p>The YAML based config files are where everything gets defined. This way a single configuration file can be used to generate multiple output formats. In the case of this projects, that's SQL files for a local postgres database, protobuf files for gRPC, and python source files for data type definitions. There is more information on the configuration files here</p>"},{"location":"build/#proto-files","title":".proto files","text":"<p>These define the messages used by gRPC, and are also generated from the configuration files. Not every column in the database tables is in a message. The fields that get send and received are defined in the configuration file by adding share: True as a setting.</p> <p>The .proto files then have to be compiled using protoc, which  generates the client and server stubs.</p>"},{"location":"build/#sql-files","title":".sql files","text":"<p>These define the messages used by gRPC, and are also generated from the configuration files. These can be executed in postgres to create the tables. The tmadmin-manage program uses these to create the database tables.</p>"},{"location":"communication/","title":"Inter Project Communication","text":"<p>While there are data structures for all the columns in the database, not all of the data fields need to be used for inter project communication. Some field data is project specific, for example, tasks in the HOT Tasking Manager(TM) are not the same as tasks in  the nHOT Field Mapping Tasking Manager(FMTM), but most of the fields are used for tasks in both.</p> <p>With any project that is designed to be embedded into other projects, there is a risk of duplicate data structures that can become a maintainance nightmare in the future, since any changes will need to be in multiple places. Each data structure is represented in the database schemas, python, and gRPC. To reduce future maintainance headaches, a single configuration file is used to generate multiple output formats. More information on that process is documented here.</p> <p>All communication is bi-directional. Projects can send data, or handle a request for data. For any data that is sent, the response is a simple SUCCESS/FAILURE message. FAILURE message also return an error message and error code.</p> <p>It seems that most of the projects start with TM. After critical tasks are mapped, they then could be migrated to FMTM for field data collection. The FMTM mappers would also be ground truthing the remote mapping. It's entirely possible that FMTM field mappers would find issues with the data extract of OSM buildings, and want to notify the TM project manager to invalidate some tasks and remap them.</p>"},{"location":"communication/#notifications","title":"Notifications","text":"<p>Some messages have nothing to do with the database, they're for communicating other types of requests. Other than just doing database updates, this is the core of an end to end data flow.</p> <p>Examples of some notifications are:</p> <ul> <li>Underpass would notify TM or fAIr of a data quality issue</li> <li>An FMTM project manager would notify TM to invalidate a task</li> <li>fAIr would notify an FMTM project manager that the imagery has been   processed so a data extract could be made</li> <li>fAIr would notify OAM that drone imagery is needed for an AOI</li> <li>OAM would notify fAIr when drone imagery is ready to be processed</li> </ul>"},{"location":"communication/#projects-exchange-user-profiles","title":"Projects exchange user profiles","text":"<p>Since a user may be contributing to multiple projects, it should be possible to clone a users profile between projects. For example, when a Tasking Manager (TM) is being worked on, some users may also be using the Field Mapping Tasking Manager (FMTM) to ground-truth the data. Or they may want to use fAIr to process the drone imagery they just collected.</p>"},{"location":"communication/#user-profiles","title":"User profiles","text":"<p>These are the data fields that need to be in this message to create a user profile in the database. The user ID in TM or FMTM won't be the same, since each project will have different teams of mappers. Instead of the ID, the username will be used to refer to a mapper.</p> <ul> <li>username</li> <li>name</li> <li>city</li> <li>country</li> <li>email_address</li> <li>is_email_verified</li> <li>is_expert</li> <li>mapping_level </li> <li>password</li> </ul>"},{"location":"communication/#receiving-project-decides-update-or-create","title":"Receiving project decides, update or create ?","text":"<p>When this message is received, it should update the database for this user unless the username already exists, and send the response acknowledgment.</p>"},{"location":"communication/#tm-sends-project-profile","title":"TM sends project profile","text":"<p>It is entirely likely that for disaster response, an area may be remotely mapped with TM, and then will be field mapped with FMTM as a  follow-up. The instructions would be very different, so aren't needed. The tasks won't be sent either, as a TM task is much largerr than an FMTM task. FMTM mappers are walking when mapping. The project ID is also not transmitted, as it'll be different in different projects. There may also be occassions where a project would be sent to fAIr, Export Tool, or Underpass.</p> <ul> <li>name</li> <li>outline</li> <li>description</li> <li>location_str</li> <li>organisation_id (spelling depends on country)</li> <li>priority</li> <li>centroid</li> </ul> <p>A project transferred to FMTM has no project manager, so these are initially only an AOI and draft project description. FMTM would need the ability to search for an unassigned project, ie... no manager. Then when there is a project manager it would be assigned to them.</p>"},{"location":"communication/#receiving-project-decides-update-or-create_1","title":"Receiving project decides, update or create ?","text":"<p>When this message is received, it should update the database for this project, and send the response acknowledgment.</p>"},{"location":"communication/#tm-sends-organization-profile","title":"TM sends organization profile","text":"<p>Organizations may be using multiple HOT projects, so this would sync organization data between projects so it wouldn't have to be manually edited for each poroject like it is now.</p> <ul> <li>name</li> <li>description</li> <li>url</li> <li>logo</li> <li>type</li> </ul>"},{"location":"communication/#receiving-project-decides-update-or-create_2","title":"Receiving project decides, update or create ?","text":"<p>When this message is received, it should update the database for this organization, and send the response acknowledgment.</p>"},{"location":"configuring/","title":"Configuring The Data Structures","text":"<p>For any project that needs to transmit data between multiple projects, there needs to be a single source of data structures and type definitions. Otherwise there winds up being a lot of code duplication which becomes hard to maintain.</p> <p>This project also needs to manage the database tables, as well as allow to transmit data between projects. Python enums and classes are also generated.</p>"},{"location":"configuring/#the-yaml-files","title":"The YAML files","text":"<p>This file is used to generate the full SQL to create database tables, as well as the protobuf files. The first field becomes the name of the tables in postgres, or the message in the .proto file. Each table is then followed by a list of fields. Each field has a few settings, the data type, and a few settings.</p> <p>For example:</p> <pre><code>- users:\n    - id:\n        - int64\n        - required: True\n        - share: True\n        - sequence: True\n ...\n</code></pre>"},{"location":"configuring/#required","title":"required","text":"<p>If this is True, then for the database table, this becomes NOT NULL in the SQL schema. This is ignored when generating the protobuf file.</p>"},{"location":"configuring/#sequence","title":"sequence","text":"<p>If this is True, then this becomes an auto incrementing sequence in SQL. This is ignored when generating the protobuf file.</p>"},{"location":"configuring/#share","title":"share","text":"<p>Not every field needs to be transfered to other projects, as some are project specific, like how many tasks have been mapped. If this is True, then it will have an entry in the protobuf message. The default is True. To have a field not appear in the protobuf message, this needs to be set to False.</p>"},{"location":"configuring/#array","title":"array","text":"<p>If this is True, then in the database schema this becomes an array. In the protobuf file, this adds the repeated keyword in the message to define this field as an array.</p>"},{"location":"configuring/#unique","title":"unique","text":"<p>if this is True, in postgres a unique constraint is generated for this, which is used for upserts.</p>"},{"location":"dataexchange/","title":"Exchanging Data","text":"<p>Exchanging data between projects has a few issues, namely the ID of the user, the project, and the organization are different in the different projects. Not all fields are useful cross-project, so some but not all of the columns in a database table are exchanged w ith other projects. There are other issues to handle, a projet manager/admin in Tasking Manager (TM) may only be a a mapper in the Field Mapping Tasking Manager (FMTM) project, so the roles change, but the rest of the user profile stays the same.</p> <p>Currently all the database tables have every column used by FMTM or TM. Since there are many application specific columns, these are simply ignored by the application. While this does make the database slightly larger having multiple empty columns, it's a tradeoff between database size and simplifying the code base. A future enhancement to the YAML config file subsystem will support using a subset of all the database columns.</p> <p>Some of the data to be exchanged is currently supported by the REST API for FMTM and TM. The plan is for these modules in the TM-Admin project work under those REST APIs for database access. This lets the REST API stay focused on supporting the web frontend for each application.</p>"},{"location":"dataexchange/#identifying-records","title":"Identifying Records","text":"<p>Since the ID can't be used between projects, the name or address is the only unique field that can be used to identify a user or an organization, etc...  For users, the best ID is their OpenStreetMap (ODM) ID, as that is unique globally. While some support can be added to track unique IDs across multiple projects, this can be cumbersome.</p> <p>Another way to identify a record is through location. Since both projects and tasks have an polygon area of interest, a point within a project in one application, can be used to query a remote project to find the project or task. For example, if a field mapper finds bad data, the location of that data can be used to find the TM project and task, so the task can be invalidated.</p>"},{"location":"dataexchange/#filtering-data","title":"Filtering Data","text":"<p>Since not all data fields are needed in each project, the YAML configuration file supports a flag for each item in a data structure as to whether it should be shared or not. For example, a database query might return many columns, but only a few are usefully portable across multiple projects.</p> <p>For instance, Tasking Manager has task boundaries, in FMTM, tasks are smaller, because it involves mappers walking. So transferrihng exact task boundaries would be meaningless. In this usage case, the tasks transfer from TM to FMTM would be a multi-polygon. FMTM would create a project AOI based on the outer boundary of all the of the tasks, and then recalulate FMTM specific tasks boundaries.</p>"},{"location":"dataexchange/#data-exchange-schemas","title":"Data Exchange Schemas","text":"<p>Some fields need to be in any data packet that is intended for database queries, since the there needs to be a way to refer to an existing record, if it exists. While it is possible to identify remote database records by comparing multiple columns, to keep things simple, it is prefered to use the name or location.</p>"},{"location":"dataexchange/#project-data","title":"Project Data","text":"<p>A project has a wide definition depending on the type of application. Since this module is focused on Tasking Manager style applications, all version will have at least a project name and an Area of Interest (AOI). In addition, each tracks task usage, so the number of tasks mapped, validated, or invalidated exists in all tables, but has different data.</p>"},{"location":"dataexchange/#field-mapping-tasking-manager","title":"Field Mapping Tasking Manager","text":"<p>For FMTM, it uses an odkid column, which is used to communicate with ODK Central. This is an example of needing to store the ID of a remote application to exchange data for specific items. How the ID of a remote project is stored may change in the future to handle multiple remote applications, but for now, it's only the one for ODK Central.</p> <p>FMTM also uses several columns for working with OpenDataKit(ODK). These are the login credentials for an ODK Central server, and an XLSForm for the project.</p>"},{"location":"dataexchange/#tasking-manager","title":"Tasking Manager","text":"<p>TM uses a series of columns that are used for editing OSM data. This includes presets for several editors. </p>"},{"location":"dataexchange/#user-data","title":"User Data","text":"<p>Most all the columns in the user profiles is the same across all applications. The are a few columns for tracking tasks mapped, etc... but the data for those will vary between applications.</p>"},{"location":"dataexchange/#organization-data","title":"Organization Data","text":"<p>Organization data is easy, all columns are used by all applications. This this table is simple, organization name, logo, URL, and a description.</p>"},{"location":"dataexchange/#task-data","title":"Task Data","text":"<p>A task AOI is not usually useful between projects, as a TM task is much larger than an FMTM task. For a Drone Tasking Manager (DTM), the task size will also be different. Since tasks are not portable across projects, each project maintains it's own data, the creation date, tasks mapped, validated, invalidated, etc...</p>"},{"location":"dataflow/","title":"TM-Admin Data Flow","text":""},{"location":"dataflow/#generated-files","title":"Generated files","text":"<p>This project attempts to minimise code duplication. It is designed to be a module for use in other projects. Because this project works with both gRPC messages and a postgres database, any changes to any of the data structures would require making changes in multiple places. Instead a single file in YAML format is used to generate all the other formats. This way changes only have to be made in one place. </p> <p>It does make the code more complicated, lots of layers of generated code stubs to dig through when debugging. I've also tried to avoid hacks in the code, and make it flexible to changes. That often involves lots of looping through various data, but it's still pretty fast. </p>"},{"location":"dataflow/#generating-the-files","title":"Generating the files","text":"<p>To generate the files, there is a standalone python class, which also has a simple command line interface and can be run offline. The generate.py file reads in the YAML config files, and creates an internal data structure for that file. More information on the config file is here.</p> <p>The actual database schemas are created from the generated SQL files. The tmadmin_manage.py file has a class that also runs standalone and generates all the SQL, python, and protobuf files using the Generate class. Once it generates the SQL files, it creates the database and tables.</p> <p>The protobuf files need to be compiled using protoc. This is easiest done using the Makefile. since it has to include the types for the complication to succeed.</p> <p>Since there are a lot of generated files, they are all in a subdirectory. Each directory is for each table in the database, and all generated files go there.</p>"},{"location":"dataflow/#datatypes","title":"Datatypes","text":"<p>There are multiple shared enums, and are defined in the types.yaml file. These become enums for postgres, python, and protobuf. After generating the files, there is types_tm.sql, types_tm.py, and a types_tm.proto for the protobuf files gRPC uses. These can be included in any of the other classes that create data types. Having portable data strucures that can be shared is critical. Otherwise any changes would require editing multiple places. Having a single definition reduces maintaince.</p>"},{"location":"dataflow/#the-python-files","title":"The Python files","text":"<p>There are python source files generated for each database table. These define all the data structures so they are easily accessible. The enums are in the types_tm.py file.</p> <p>The other two files are classes that define the full data for SQL queries, as well as the reduced dataset used in inter-project data exchange using gRPC. Using the table name, these become tableTable or tableMessage. The class files are for storing the data for a table. The tableMessage classes are the reduced datasets for exchanging data. Not all data in a database is useful in multiple projects, so this uses a setting in the YAML config file to not have all columns in the gRPC message.</p> <p>Each table also has a class designed for accessing the database. This file is not generated. This uses the other generated python files for the data structures. This handles creating the entries for the tables, and also has a few common queries, like search by ID. Most of the higher level processing will be handled by the project importing this module since it's possible to get the full data for furthur processing. This is to make it a less painful refactoring of an existing project backend. Many projects have existing tests of the values in the database columns, so this is still possible.</p>"},{"location":"dataflow/#instantiating-an-object","title":"Instantiating an object","text":"<p>The generated python files allow for default values for all the database tables, and conditional parameters in python. With each top level class for a tables, </p> <p>For example:     ut = UsersTable(name='fixme', mapping_level='BEGINNER')</p> <p>Creates a dictionary in the class with all of the keywords from the YAML file. but will set these two columns to these values. This is used for both creating entries in the database, but also for updating them. This handles multiple optional parameters allowing this data object to be used for data exchange in a consistent fashion.</p>"},{"location":"dataflow/#sql-files","title":"SQL files","text":"<p>The SQL files are designed to work with postgres for creating the database, and it's tables and data types. The config file format allows for setting each column as an auto incrementing column (good for IDs), setting that are required, so become 'NOT NULL'. And also a unique column, which is used for an INSERT that may trigger a conflict. This is useful to update existing data.</p>"},{"location":"dataflow/#protobuf-files","title":"Protobuf files","text":"<p>The protobuf files are used by gRPC to exchange data. The protoc compiler produces other wrappers as python code for the data structures. These also use the table name as the prefix, and creates table_pb2.py or table_pb2_grpc.py. These are used with gRPC. The other generated python class are designed to interface with these, since they need data structures to exchange.</p>"},{"location":"endpoints/","title":"REST API Endpoints","text":"<p>This is a comparison between the endpoint of Tasking Manager and the Field Mapping Tasking Manager. The goal of the TM Admin project is to support these endpoints. There is also not an obvious 1-1 relationship between endpoints the support class in TM Adamin. Endpoints are higher level than the code in TM Admin.</p> <p>For the common functions like querying the database by ID or name, these are in a base class, so shared.</p>"},{"location":"endpoints/#users","title":"Users","text":"<p>Endpoints for managing User profiles.</p> Tasking Manager FMTM TM Admin Get paged list of all usernames Get Users UsersDB.getAll() Registers users without OpenStreetMap account UsersDB.createTable() Updates user info UsersDB.updateTable() Get user information by OpenStreetMap username UsersDB.getByName() Get stats about users registered within a period of time UsersDB.getByWhere() Get user information by id Get User by ID UsersDB.getByID() Allows user to enable or disable expert mode UsersDB.updateExpert() Allows PMs to set a user's mapping level UsersDB.updateMappingLevel() Allows PMs to set a user's role UsersDB.updateRole() Get a list of tasks a user has interacted with UsersDB.getByWhere() Resends the verification email token to the logged in user Get recommended projects for a user Get details from OpenStreetMap for a specified username Get detailed stats about a user by OpenStreetMap username Get paged lists of users matching OpenStreetMap username filter Get User Roles"},{"location":"endpoints/#organizations","title":"Organizations","text":"<p>Endpoints for managing Organization profiles.</p> Tasking Manager FMTM TM Admin List all organisations Get Organization OrganizationsDB.getAll() Creates a new organisation Create Organization OrganizationsDB.createTable() Deletes an organisation Delete Organizations OrganizationsDB.deleteByID Retrieves an organisation Get Organization Detail OrganizationsDB.getByID() Updates an organisation Update Organization OrganizationsDB.updateTable() Return statistics about projects and active tasks of an organisation"},{"location":"endpoints/#projects","title":"Projects","text":"<p>Endpoints for managing projects.</p> Tasking Manager FMTM TM Admin List and search for projects Read Projects projectsDB.getAll() Creates a tasking-manager project Create Project projectsDB.createTable() List and search projects by bounding box projectsDB.getByLocation() Get featured projects projectsDB.updateTable() Get all projects for logged in admin projectsDB.getByWhere() Get popular projects projectsDB.getByWhere() Get similar projects projectsDB.getByWhere() Gets projects user has mapped projectsDB.getByWhere() Deletes a Tasking-Manager project Delete Project projectsDB.deleteByID() Get a specified project including it's area Get Project Details projectsDB.getByID() Updates a Tasking-Manager project Update Project projectsDB.updataTable() Set a project as featured projectsDB.updateColumn() Send message to all contributors of a project Unset a project as featured projectsDB.updateColumn() Transfers a project to a new user projectsDB.updateColumn() Get all user activity on a project projectsDB.getByWhere() Get latest user activity on all of project task projectsDB.getByWhere() Get all user contributions on a project projectsDB.getByWhere() Get contributions by day for a project projectsDB.getByWhere() Get AOI of Project projectsDB.getByID() Upload Custom XLSForm Project Partial Update Upload Multi Project Boundary Task Split Upload Project Boundary Edit Project Boundary Update Odk Credentials Validate Form Generate Files Get Data Extracts Update Project Form Get Project Features Generate Log Get Categories Preview Tasks Add Features Download Form Update Project Category Download Template Download Project Boundary Download Task Boundaries Download Features Generate Project Tiles Tiles List Download Tiles Download Task Boundary Osm Project Centroid"},{"location":"endpoints/#tasks","title":"Tasks","text":"<p>Endpoints for managing tasks in a project.</p> Tasking Manager FMTM TM Admin Delete a list of tasks from a project Get all tasks for a project as JSON Read Tasks tasksDB.getAll() Extends duration of locked tasks tasksDB.getByWhere() Invalidate all validated tasks on a project Locks a task for mapping tasksDB.updateColumn() Lock tasks for validation tasksDB.updateColumn() Map all tasks on a project Set all bad imagery tasks as ready for mapping tasksDB.updateTable() Reset all tasks on project back to ready, preserving history Revert tasks by a specific user in a project Split a task Unlock a task that is locked for mapping resetting it to its last status tasksDB.updateTable() Unlock tasks that are locked for validation resetting them to their last status tasksDB.updateTable() Undo a task's mapping status Update Task Status tasksDB.updateTable() Set a task as mapped Update Task Status tasksDB.updateTable() Set tasks as validated Update Task Status tasksDB.updateTable() Validate all mapped tasks on a project Update Task Status tasksDB.updateTable() Get task tiles intersecting with the aoi provided tasksDB.getByLocation() Get all tasks for a project as GPX tasks.getAll() Get all mapped tasks for a project grouped by username Get all tasks for a project as OSM XML Get a task's metadata Get Task Get invalidated tasks either mapped by user or invalidated by user Get Task Stats Get Qr Code List Edit Task Boundary Task Features Count"},{"location":"generator/","title":"generator.py","text":"<p>This program generates the SQL, Protobuf, and Python data structures needed by all the other code. It reads ih nthe YAML config file, and outputs the language bindings.</p> <pre><code>usage: generator [-h] [-v] files...\n\noptions:\n    -h, --help    show this help message and exit\n    -v, --verbose verbose output\n</code></pre>"},{"location":"generator/#example","title":"example","text":"<pre><code>./generator -v users/users.yaml\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":"<p>This document assume you have cloned the git respository, and are at the top level. While the top level Makefile is mostly for convienience, the real work is done by lower level Makefiles.</p> <p>This projects uses many generated files, which does add dependancy issues around processing steps in the right order. The rough steps in order are:</p> <ul> <li>Clone the source</li> <li>Generate all the language binding files</li> <li>Create the postgres database</li> <li>Import the generated SQL files into postgres</li> <li>install the python modules</li> </ul> <p>The simple way to get started is to type make, which will generate all the files, followed by pip install ., which will install the python modules.</p> <p>Documentation on the python modules is available via pydoc tm_admin, and is also available in more detail from the TM Admin docs website.</p> <p>After this is done, you can optionally import the existing Tasking Manager database using the tmdb.py program. This can take a long time, as the schemas aren't the same, so should be done as a background task, preferably on a different computer as it may take many hours or several days depending on the hardware.</p>"},{"location":"getting_started/#makefile-targets","title":"Makefile Targets","text":"<p>There is a Makefile in the tm_admin directory that does much of the work of generating all the output files with the proper options, and in the right order. It is recommended that developers use this instead of generating files for an indivigual YAML config file. Most users wil lnever need this commands, they're primarily for development and deployments.</p>"},{"location":"getting_started/#make-all","title":"make all","text":"<p>By default, just typing make will run the all target, which will execute all the dependant targets first.</p>"},{"location":"getting_started/#make-clean","title":"make clean","text":"<p>This target removes all the generated files generated by this project. This is primarily of use only to developers. But if you are trying to work on this project, when you have weird problems, start with clean files.</p>"},{"location":"getting_started/#make-realclean","title":"make realclean","text":"<p>This also runs the clean target, but additionally removes all the text editing backups, and the pycache. Sometimes whern debugging there are issues with the python cache, so removing it makes for a clean start.</p>"},{"location":"getting_started/#make-support","title":"make support","text":"<p>This target generates the types_tm. files, which defined all the data types for SQL, Python, and Protobuf. This is run automatically when using the generate target.</p>"},{"location":"getting_started/#make-generate","title":"make generate","text":"<p>This generates all the language binding files for Postgrers, Python, and Protobuf. If the files exist, they will not get regenerated unless changes to the YAML files are made. It's bettter to regenerate everything though, so run make clean first. To use make to regenerate indivigual files, this will generate the initial files for Postgres and the protobuf config files.</p> <pre><code>make tasks/task_history.sql\n</code></pre> <p>It is also possible to run the protobuf compiler (protoc) manually for indivigual files. This will generate the python wrappers to use protobuf using the XXX.proto source file, which has already been created by the generator.py program.</p> <pre><code>PROTOC=protoc\nGRPC = --grpc_python_out=. --plugin=protoc-gen-grpc_python=/usr/bin/grpc_python_plugin\n$(PROTOC) -I. --python_out=. $(GRPC) types_tm.proto  XXX.proto\n</code></pre>"},{"location":"getting_started/#make-create","title":"make create","text":"<p>This uses the tmadmin-manage.py program to create the schema in the database.</p>"},{"location":"getting_started/#make-docs","title":"make docs","text":"<p>In addition to the Doxygen API documentation, it is also possible to generate an API document of the generated Protobuf files.</p>"},{"location":"importing/","title":"Importing Tasking Manager Data","text":"<p>It is possible to import the entire database from an existing Tasking Manager (TM) into the new schema.  This should only need to be done once if transitioning to using tm-admin as the backend for TM. It is also useful for development, as their is no better way to make sure tm-admin can support the backend needs of a Tasking Manager style project.</p>"},{"location":"importing/#the-initial-import","title":"The Initial Import","text":"<p>The TM database schema uses small two column tables to relate various IDs together using a postgre SQL. This is inefficient, tm-admin uses postgres arrays and nested tables instead to limit doing multiple queires in sequency to get simple results from the initial query.</p> <p>The primary tables are:</p> <ul> <li>tasks</li> <li>users</li> <li>projects</li> <li>organizations</li> <li>campaigns</li> <li>teams</li> <li>messages</li> <li>notifications</li> </ul> <p>Changes between the TM schema and the one used by tm-admin are documented here.</p> <p>tmdb.py</p>"},{"location":"importing/#importing-the-supplementary-tables","title":"Importing The Supplementary Tables","text":"<p>Each directory has a python file that will read the data from a TM database table, but for tm-admin, it gets merged in as either an array or a nested table.</p> <ul> <li>users</li> <li>projects</li> <li>tasks</li> </ul>"},{"location":"pgasync/","title":"Async Data Flow","text":"<p>To avoid some performance issues, all communication with the database is async using the asyncpg module. If using the async model in SQLAlchemy, it uses asyncpg as well. Performance wise, depending on the actual operation, asyncpg may be faster than psycopg2 or not.</p>"},{"location":"pgasync/#initialization","title":"Initialization","text":"<p>When using asyncpg, the init() method in a class cannot have any calls to an async routine. This is because it's a constructor. This then requires two steps to initialize a class. The first one constructs an instantiation of the class, the following line then calls connect, whichfrom then on is fully async.</p>"},{"location":"pgasync/#defining-methods","title":"Defining methods","text":"<p>Each class must have async in front of the def if it is to call any async code. Since this gets messy really fast, I just make all the defs async to avoid confusion. For example:</p> <pre><code>async def importDB(self, table: str, ):\n</code></pre>"},{"location":"pgasync/#calling-a-method","title":"Calling A Method","text":"<p>To call any async method, you need to prefix it with await. I think of it this way, async def puts the task on a list, and await pulls it out. Nice and simple. For example:</p> <pre><code>data = await self.tmdb.execute(sql)\n</code></pre> <p>If you get an error message about coroutines, that means you forgot the await keyword.</p> <pre><code>sys:1: RuntimeWarning: coroutine 'TmAdminManage.createTable' was never awaited\n</code></pre>"},{"location":"pgasync/#threading","title":"Threading","text":"<p>Originally this propject was using concurrent.futures for threading, but has switched entirely to the asynio module using asychronis tasks instead of threads since everything is designed to work together.</p> <p>All the code is heavily threaded. Data is split into chunks based on the number of CPU cores. Then each chunk is then handed off to an async Task to process the data. Since the threading is buried deep in this API, it shouldn't be needed in most applications using the TM-Admin API will need to do threading at a higher level for any of the data flow.</p>"},{"location":"pgsupport/","title":"pgsupport.py","text":"<p>This class has support for managing the database tables, and is derived from the PostgresClient class. It is a wrapper on top of pgasync, and focused on the client side of the internal API. It has helper functions for commen queries, as well as providing a simpiler interface for querying and updating data than raw SQL. It uses the generated __class.py_ files that define each database table as the primary data structure. This class gets instantiated for each table in the data getting frequent access. It also uses all of the enums defined in the generated *types_tm.py file.</p> <p>One of the primary functions of this class is handling all the datatype conversion. When using jsonb columns in postgres, there is no datatype information. For strings and numbers this is fine, but not for jsonb columns. Since the jsonb columns are also defined by the same yaml config files all the other tables use, it's possible to get the datatype of each value in the jsonb array. This will then contain the string name of the Enum. If querying the table directly, this will be returned as an string value. If querying with the API defined in each table's api.py file, the value is returned as a Python Enum.</p> <p>Python dictionaries are heavily used as a parameter. All of the generated data structures use a similar naming convention, so all the data structures are very dynamic. Any change to the yaml config files gets propogated to all the language bindings. Enum values are used everywhere, improving the code readability.</p> <p>To support prepared SQL statements, most of the API functions take a list or a dictionary of multiple entries. The functions for querying or updating data take two parameters.</p>"},{"location":"pgsupport/#inserting-a-record","title":"Inserting A Record","text":"<p>For example, to insert or update a record in the projects table, use the generated ProjectsTable class. The insertRecords() method takes a list of Table classes. The id column is a sequence variable, so will auto-increment if no id is specified. If the id is specifed in the Table data structure, then that is the value used for the record. Inserting a record with an id is only used when importing data from the Tasking Manager. This function returns the id column of the just inserted record.</p> <p>In this example, GRID, DRAFT, and INTERMEDIATE are all enums. The teams column in this example is a jsonb column in the table, so defined by a dictionary. Updating a record uses the same class, which directly maps to the table schema.</p> <pre><code>from tm_admin.projects.projects_class import ProjectsTable\n\nteams = {\"team_id\": 2, \"role\": \"TEAM_MAPPER\"}\npt = ProjectsTable(author_id=1, geometry=geom, centroid=center,\n                    created='2022-10-15 09:58:02.672236',\n                    task_creation_mode='GRID', status='DRAFT',\n                    mapping_level='INTERMEDIATE', teams=teams)\nid = await pgs.insertRecords([pt])\n</code></pre>"},{"location":"pgsupport/#querying-the-database","title":"Querying The Database","text":"<p>As the database schema is reasonably complex, with a mix of arrays and jsob columns, the API supports basic querying operations. Much database accesss is querying or changing a single colum. There some helper functions for common querying by the id or name of a project, user, etc...</p> <p>These following examples are for accessing the data for a column. More than one column can be specifed to be in the output data. By default, all the records for the specified columns is returned. It is also possible to specify a clause for WHERE. This can be a value, or IS NULL. A dictionary is used for the conditional. When multiple conditionals are used, the default is to OR between them.</p> <p>For example, get all the records in a table:</p> <pre><code>data = await pgs.getColumns(['id', 'teams'])\n</code></pre> <p>Get the team with an ID of 144:</p> <pre><code>foo = {'id': 144}\ndata = await pgs.getColumns(['id', 'teams'], [foo])\n</code></pre> <p>Get the columns in the team where the role is TEAM_READ_ONLY and the team ID is 144. This queries a jsonb column:</p> <pre><code>foo = {'teams': {\"role\": tm_admin.types_tm.Teamroles.TEAM_READ_ONLY, \"team_id\": 144}}\ndata = await pgs.getColumns(['id', 'teams'], [foo])\n</code></pre>"},{"location":"pgsupport/#getting-data","title":"Getting Data","text":"<p>The first parameter is the columns to return from query. The second is the conditions for the WHERE clause in SQL. If there is no second parameter, then all the data in the requested columns is returned.</p> <p>This example returns the list of teams and roles for this project. Multiple conditions for WHERE can be specified, when converted to SQL they use an OR betweeen them. If \"null\" is used as the value, then in SQL this becomes \"IS NOT NULL\". The returned data is always a list, even if it contains only a single entry.</p> <pre><code>project_id = 15173\ndata = await projects.getColumns(['teams', 'name'],  [{\"id\": project_id}])\n</code></pre>"},{"location":"pgsupport/#updating-a-table","title":"Updating a Table","text":"<p>Updating a record is more complicated since some columns are JSONB or arrays. This function takes two dictionaries. The first parameter defines the column to update, the second is the WHERE clause. This function returns the id column of the just update record, or zero if no records match the WHERE criteria.</p> <p>If there is no WHERE clause, then all the records in the table are updated.</p> <pre><code>foo = {\"featured\": \"true\"}\ndata = await projects.updateColumns(foo)\n</code></pre> <p>Enums are also supported, as they are used heavily in this project as opposed to just the numerical value. This makes the code and the table data more readable.</p> <pre><code>foo = {\"featured\": \"true\", \"difficulty\": tm_admin.types_tm.Projectdifficulty.CHALLENGING}\nproject_id = 1\ndata = await projects.updateColumns(foo, {\"id\": project_id})\n</code></pre>"},{"location":"protos-api/","title":"Protocol Documentation","text":""},{"location":"protos-api/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>services.proto</p> <ul> <li>notification</li> <li>tmrequest</li> <li>tmresponse</li> <li> <p>tmresponse.DataEntry</p> </li> <li> <p>TMAdmin</p> </li> </ul> </li> <li> <p>types_tm.proto</p> <ul> <li>Bannertype</li> <li>Command</li> <li>Editors</li> <li>Encouragingemailtype</li> <li>Mappinglevel</li> <li>Mappingnotallowed</li> <li>Mappingtypes</li> <li>Notification</li> <li>Organizationtype</li> <li>Permissions</li> <li>Projectdifficulty</li> <li>Projectpriority</li> <li>Projectstatus</li> <li>Taskaction</li> <li>Taskcreationmode</li> <li>Taskstatus</li> <li>Teamjoinmethod</li> <li>Teammemberfunctions</li> <li>Teamroles</li> <li>Teamvisibility</li> <li>Usergender</li> <li>Userrole</li> <li>Validatingnotallowed</li> </ul> </li> <li> <p>organizations/organizations.proto</p> <ul> <li>organizations</li> </ul> </li> <li> <p>projects/projects.proto</p> <ul> <li>projects</li> </ul> </li> <li> <p>tasks/tasks.proto</p> <ul> <li>tasks</li> </ul> </li> <li> <p>teams/teams.proto</p> <ul> <li>teams</li> </ul> </li> <li> <p>users/users.proto</p> <ul> <li>users</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"protos-api/#servicesproto","title":"services.proto","text":""},{"location":"protos-api/#notification","title":"notification","text":"Field Type Label Description note Notification"},{"location":"protos-api/#tmrequest","title":"tmrequest","text":"Field Type Label Description cmd Command id int64 name string"},{"location":"protos-api/#tmresponse","title":"tmresponse","text":"Field Type Label Description error_code int32 error_msg string data tmresponse.DataEntry repeated message Data {   map&lt;string, string&gt; pairs = 3;    } repeated Data data = 4;"},{"location":"protos-api/#tmresponsedataentry","title":"tmresponse.DataEntry","text":"Field Type Label Description key string value string"},{"location":"protos-api/#tmadmin","title":"TMAdmin","text":"<p>The greeting service definition.</p> Method Name Request Type Response Type Description doRequest tmrequest tmresponse These are for handling tmrequest for profile data from the database doNotification notification tmresponse updateUserProfile users users updateProjectProfile projects projects updateTeamProfile teams teams updateTask tasks tasks updateOrganizationProfile organizations organizations <p></p> <p>Top</p>"},{"location":"protos-api/#types_tmproto","title":"types_tm.proto","text":""},{"location":"protos-api/#bannertype","title":"Bannertype","text":"Name Number Description INFO 0 WARNING 1"},{"location":"protos-api/#command","title":"Command","text":"Name Number Description GET_USER 0 GET_ORG 1 GET_PROJECT 2 GET_TEAM 3"},{"location":"protos-api/#editors","title":"Editors","text":"Name Number Description ID 0 JOSM 1 POTLATCH_2 2 FIELD_PAPERS 3 CUSTOM 4 RAPID 5"},{"location":"protos-api/#encouragingemailtype","title":"Encouragingemailtype","text":"Name Number Description PROJECT_PROGRESS 0 PROJECT_COMPLETE 1 BEEN_SOME_TIME 2"},{"location":"protos-api/#mappinglevel","title":"Mappinglevel","text":"Name Number Description BEGINNER 0 INTERMEDIATE 1 ADVANCED 2"},{"location":"protos-api/#mappingnotallowed","title":"Mappingnotallowed","text":"Name Number Description USER_ALREADY_HAS_TASK_LOCKED 0 USER_NOT_CORRECT_MAPPING_LEVEL 1 USER_NOT_ACCEPTED_LICENSE 2 USER_NOT_ALLOWED 3 PROJECT_NOT_PUBLISHED 4 USER_NOT_TEAM_MEMBER 5 PROJECT_HAS_NO_OSM_TEAM 6 NOT_A_MAPPING_TEAM 7"},{"location":"protos-api/#mappingtypes","title":"Mappingtypes","text":"Name Number Description ROADS 0 BUILDINGS 1 WATERWAYS 2 LAND_USE 3 OTHER 4"},{"location":"protos-api/#notification_1","title":"Notification","text":"Name Number Description BAD_DATA 0 BLOCKED_USER 1 PROJECT_FINISHED 2"},{"location":"protos-api/#organizationtype","title":"Organizationtype","text":"Name Number Description FREE 0 DISCOUNTED 1 FULL_FEE 2"},{"location":"protos-api/#permissions","title":"Permissions","text":"Name Number Description ANY_PERMISSIONS 0 LEVEL 1 TEAMS 2 TEAMS_LEVEL 3"},{"location":"protos-api/#projectdifficulty","title":"Projectdifficulty","text":"Name Number Description EASY 0 MODERATE 1 CHALLENGING 2"},{"location":"protos-api/#projectpriority","title":"Projectpriority","text":"Name Number Description URGENT 0 HIGH 1 MEDIUM 2 LOW 3"},{"location":"protos-api/#projectstatus","title":"Projectstatus","text":"Name Number Description ARCHIVED 0 PUBLISHED 1 DRAFT 2"},{"location":"protos-api/#taskaction","title":"Taskaction","text":"Name Number Description RELEASED_FOR_MAPPING 0 LOCKED_FOR_MAPPING 1 MARKED_MAPPED 2 LOCKED_FOR_VALIDATION 3 VALIDATED 4 MARKED_INVALID 5 MARKED_BAD 6 SPLIT_NEEDED 7 RECREATED 8 COMMENT 9"},{"location":"protos-api/#taskcreationmode","title":"Taskcreationmode","text":"Name Number Description GRID 0 CREATE_ROADS 1 UPLOAD 2"},{"location":"protos-api/#taskstatus","title":"Taskstatus","text":"Name Number Description READY 0 TASK_LOCKED_FOR_MAPPING 1 TASK_STATUS_MAPPED 2 TASK_LOCKED_FOR_VALIDATION 3 TASK_VALIDATED 4 TASK_INVALIDATED 5 BAD 6 SPLIT 7 TASK_ARCHIVED 8"},{"location":"protos-api/#teamjoinmethod","title":"Teamjoinmethod","text":"Name Number Description ANY_METHOD 0 BY_REQUEST 1 BY_INVITE 2"},{"location":"protos-api/#teammemberfunctions","title":"Teammemberfunctions","text":"Name Number Description MANAGER 0 MEMBER 1"},{"location":"protos-api/#teamroles","title":"Teamroles","text":"Name Number Description TEAM_READ_ONLY 0 TEAM_MAPPER 1 VALIDATOR 2 PROJECT_MANAGER 3"},{"location":"protos-api/#teamvisibility","title":"Teamvisibility","text":"Name Number Description PUBLIC 0 PRIVATE 1"},{"location":"protos-api/#usergender","title":"Usergender","text":"Name Number Description MALE 0 FEMALE 1 SELF_DESCRIBE 2 PREFER_NOT 3"},{"location":"protos-api/#userrole","title":"Userrole","text":"Name Number Description USER_READ_ONLY 0 USER_MAPPER 1 ADMIN 2"},{"location":"protos-api/#validatingnotallowed","title":"Validatingnotallowed","text":"Name Number Description USER_NOT_VALIDATOR 0 USER_LICENSE_NOT_ACCEPTED 1 USER_NOT_ON_ALLOWED_LIST 2 PROJECT_NOT_YET_PUBLISHED 3 USER_IS_BEGINNER 4 NOT_A_VALIDATION_TEAM 5 USER_NOT_IN_TEAM 6 PROJECT_HAS_NO_TEAM 7 USER_ALREADY_LOCKED_TASK 8 <p>Top</p>"},{"location":"protos-api/#organizationsorganizationsproto","title":"organizations/organizations.proto","text":""},{"location":"protos-api/#organizations","title":"organizations","text":"Field Type Label Description id int64 name string slug string logo string description string url string orgtype Organizationtype <p>Top</p>"},{"location":"protos-api/#projectsprojectsproto","title":"projects/projects.proto","text":""},{"location":"protos-api/#projects","title":"projects","text":"Field Type Label Description id int64 odkid int64 author_id int64 created google.protobuf.Timestamp project_name_prefix string task_type_prefix string location_str string outline bytes status Projectstatus private bool mapper_level Mappinglevel priority Projectpriority centroid bytes hashtags string repeated <p>Top</p>"},{"location":"protos-api/#taskstasksproto","title":"tasks/tasks.proto","text":""},{"location":"protos-api/#tasks","title":"tasks","text":"Field Type Label Description id int64 project_task_name string outline bytes geometry_geojson string <p>Top</p>"},{"location":"protos-api/#teamsteamsproto","title":"teams/teams.proto","text":""},{"location":"protos-api/#teams","title":"teams","text":"Field Type Label Description id int64 name string logo string description string invite_only bool visibility Teamvisibility <p>Top</p>"},{"location":"protos-api/#usersusersproto","title":"users/users.proto","text":""},{"location":"protos-api/#users","title":"users","text":"Field Type Label Description id int64 username string name string city string country string tasks_mapped int32 tasks_invalidated int32 projects_mapped int32 repeated date_registered google.protobuf.Timestamp last_validation_date google.protobuf.Timestamp password string osm_id int64 facebook_id int64 irc_id int64 skype_id int64 slack_id int64 linkedin_id int64 twitter_id int64 picture_url string gender int32"},{"location":"protos-api/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"roles/","title":"Managing Roles &amp; Permissions","text":"<p>Currently there are two sets of roles in Tasking Manager style projects, users and teams, The team roles only apply to teams, a users indivigual role is used for mapping. For a user on a team, their role is derived from the team's role.</p> <p>While it would be possible to implement complex access rules for most operations, I think a ladder approach is easiest. Operations just require a certain minimal role level. For example, an assocate project manager might be able to update a project profile, but not be able to delete it. It is entirely possible that an associate project mamager would be helping with managing mappers and team profiles as well.</p>"},{"location":"roles/#team-roles","title":"Team Roles","text":"<p>The HOT Tasking Mannager (Tasking Manager) has these team roles:</p> <pre><code>- teamroles:\n    - READ_ONLY\n    - MAPPER\n    - VALIDATOR\n    - MANAGER\n</code></pre> <p>The HOT Field Mapping Tasking Manager (FMTM) doesn't quite have the same concept as an OSM Team, as it uses OpenDataKit (ODK) instead of OpenStreetMap (OSM). If a field mappers using FMTM are also in an OSM Teams, they should be able to use OSM Teams from FMTM, but Teams support in FMTM is not something on the roadmap. It is entirely likely field mapper may want to form a team, whether they have an OSM account or not. For now, FMTM doesm't need to add any additional roles. </p>"},{"location":"roles/#user-roles","title":"User Roles","text":"<p>The HOT Tasking Mannager (Tasking Manager) has these user roles:</p> <pre><code>- userrole:\n    - USER_READ_ONLY\n    - MAPPER\n    - ADMIN\n    - PROJECT_MANAGER\n</code></pre> <p>The expanded set of roles used by the Field Mapping Tasking Manager (FMTM) is:</p> <pre><code>- userrole:\n    - FIELD_ADMIN\n    - ORGANIZATION_ADMIN\n    - PROJECT_MANAGER\n    - ASSOCIATE_MANAGER\n    - VALIDATOR\n    - WEB_ADMIN\n</code></pre> <p>A difference here is FMTM has VALIDATOR as a user roles, where Tasking Manager has it as a team role. Other changes are the addition of multiple administrative roles. Since roles aren't portable across projects, this can be ignored. I'm not sure SUPER_ADMIN and WEB_ADMIN are needed, it seems those access permissions would be handled by postgres directly. Currently FMTM is not using most of these roles yet, and is linmited to READ_ONLY (the default), ADMIN, and VALIDATOR.</p>"},{"location":"roles/#data-exchange","title":"Data Exchange","text":"<p>Since this project supports data exchange between projects, it's worth nothing that roles are not portable across projects. Even withnin Tasking Manager, a project manager in one project only may be  mapper in another, Especially for Tasking Manager projects transferred to FMTM.</p> <p>There are other limitations, for example, the ability to send and receive data from other projects other than automated messages.</p>"},{"location":"roles/#role-handling","title":"Role Handling","text":""},{"location":"roles/#tasking-manager-role-handling","title":"Tasking Manager Role Handling","text":"<p>The Tasking Manager has a rich set of roles. Initially all roles were user roles, but currently these have been replaced by team roles. The user role is now derived from the team role. By default, all teams and users are READ_ONLY. Only an ADMIN, VALIDATOR, or PROJECT_MANAGER can change a user or team role.</p>"},{"location":"roles/#fmtm-role-handling","title":"FMTM Role Handling","text":"<p>Currently FMTM only supports the ADMIN and READ_ONLY roles. READ_ONLY limits users to only viewing publically accessible projects. The ADMIN is the only one who can create, modify, or delete projects.</p>"},{"location":"roles/#tasking-manager-admin-roles","title":"Tasking Manager Admin Roles","text":"<p>Since TM-Admin supports multiple projects, it has an enhanced set of roles and permissions. The roles for each project are defined in a configuration file to allow for project specific roles and access permissions.</p>"},{"location":"roles/#mapper","title":"Mapper","text":"<p>For Tasking Manager, a MAPPER is tracing features using satellite imagery with the goal of adding these to OSM. By default, a new user or team is READ_ONLY, and limited to only viewing public projects.</p> <p>For FMTM, a mapper is using ODK Collect to collect data, not all of which is for OSM. Once a mapper is logged into FMTM, then they hgain the MAPPER role, whic allows them to download the XForm, data extract, and imagery basemap.</p>"},{"location":"roles/#organization-manager","title":"Organization Manager","text":"<p>The ORGANIZATION_MANAGER is responsible for creating and maintaining the organization profile for the TM or FMTM. They would be responsible for specifying a PROJECT_MANAGER for the organization's projects. The ORGANIZATION_MANAGER is also responsbile to create the campign for a mapping project.</p>"},{"location":"roles/#project-manager","title":"Project Manager","text":"<p>The project manager is responsible for creating and maintaining project profiles. They have the ability to delete projects when necessary.</p>"},{"location":"roles/#associate-manager","title":"Associate Manager","text":"<p>The ASSOCIATE_MANAGER is usually a PROJECT_MANAGER in training, and has most of the permissions of a project manager other than project or campaign creation or deletion. Their role is to support the PROJECT_MANAGER, who may be responsible for multiple projects.</p> <p>The ASSOCIATE_MANAGER also doubles as the FIELD_ADMIN, as it's not uncommon to need somebody in the field to unlock tasks</p>"},{"location":"roles/#validator","title":"Validator","text":"<p>For Tasking Manager, the VALIDATOR role is responsible to sign off on the quality of the features that have been traced. They have the abilit to modify the task status to be invalidated. This may be due to poor building geometry, unconnected highway segments, or unsupport tag or values. Often the PROJECT_MANAGER is also the VALIDATOR, so any PROJECT_MANAGER would also have permissions to validate. With the implementation of teams, it is also possible that there will be a team of validators for a project.</p> <p>Since FMTM uses ODK, the chances of bad tag values is limited, but not always, as it is possible to incorrectly answer a question, or misspellings in text fields. If a user consistently makes the same mistakes, a task may be invalidated requiring that task to be mapped again. Since FMTM supports both public data for OSM, and private data for the project sponsors, the VALIDATOR will also make sure no private data, like gender for example, leaks into OSM.</p>"},{"location":"roles/#permission-categories","title":"Permission Categories","text":"<p>Permissions are based on the user or team role. In FMTM, this is simple, for TM, it's much more complicated, as often it involves the mappers level within OSM as well.</p> <p>It's common in the industry to use these 4 high-level permissions for access control. All other permissions are based on top of these, and of course the role is also taken into consideration.</p>"},{"location":"roles/#read","title":"read","text":"<p>This access is limited to read-only access of public facing content. This the default for users and teams until somebody with higher permissions updates it.</p>"},{"location":"roles/#create","title":"create","text":"<p>This access allows the create of projects, organizations, and campaigns.</p>"},{"location":"roles/#delete","title":"delete","text":"<p>This allows for the deletion of projects, organizations, and campaigns.</p>"},{"location":"roles/#modify","title":"modify","text":"<p>This allows for the modification of projects, organizations, and campaigns.</p>"},{"location":"roles/#team-permissions","title":"Team Permissions","text":"<p>Team support for TM is implemented using OSM Teams, and are created on the OSM Teams website by a project or organization manager. It is not required for all mappers to be in a team. For mappers on a team, they inherit the team role, and don't have a user role. Users not in a team still have a user role. For a user to join a team, they are invited via email, and have to respond to the email before they are officially on a team.</p>"},{"location":"roles/#user-permissons","title":"User Permissons","text":"<p>For users not in a team, the default is a MAPPER, which lets them select tasks and start mapping. The project manager or admin can update a users role. Only an admin can designate a mapper to be an admin.</p>"},{"location":"roles/#implementation","title":"Implementation","text":"<p>To support multiple projects with different needs, the role &amp; permissions module uses a configuration file in YAML format. This defines the roles and their permissions as they relate to the 4 primary operations used by the industry standard RBAC for access control. These control acccess to the database tables.</p> <ul> <li>create</li> <li>update</li> <li>delete</li> <li>read</li> </ul>"},{"location":"roles/#config-file","title":"Config File","text":"<p>The confg file has two primary top level tags, domains that list all the tables, and permissions, which is where the actual settings are. Under the permissions tags, the next level is the role of the user or team. These are a direct match to the types defined in python and SQL. Each tag lists the RBAC access permissions.  Since there can be a hierarchtical relationshop between roles, a role can include the values from other roles. This is done using the children tag. For example, the validator can is inherits values from the mapper tag. Since not all roles can access all tables, they are listed under the tables tag. Since roles inherit values from their children, only the additionalo tables the rols can access need to be listed.</p> <pre><code>- domains:\n    - teams\n    - users\n    - organizations\n    - projects\n    - tasks\n    - users\n    - messages\n    - notications\n    - campaigns\n\n- permissions:\n    - mapper:\n        - read\n        - tables:\n            - projects\n            - tasks\n            - users\n            - messages\n            - campaigns\n\n- validator:\n    - update\n        - children:\n            - mapper\n        - tables:\n            - projects\n            - tasks\n            - users\n\n... more roles\n</code></pre>"},{"location":"roles/#api","title":"API","text":"<p>There are defined roles that can apply across all projects. This is a super-set of the roles a project may support. For a project, the roles are defined in the config file, and wil lbe a subset of these values.</p> <ul> <li>READ_ONLY</li> <li>ORGANIZATION_ADMIN</li> <li>PROJECT_MANAGER</li> <li>ASSOCIATE_MANAGER</li> <li>VALIDATOR</li> <li>MAPPER</li> </ul> <p>The API to check access permissions for a role is simple, and requires the table name, the role, and the operation. While some operations in the backend for a website will use the role to determine access to other functionality, most operations require database access, so this controls that lower level access. Most simple operations, like a mapper locking a task to map have to update the database, so this allows the backend to control access for most operations.</p> <p>For example, this checks to make sure a mapper can read the campaigns table. if sucessful, it returns True.</p> <pre><code>await acl.check('campaigns', Roles.MAPPER, Operation.READ)\n</code></pre> <p>In this example, the mapper is trying to create a campaign, but lacks the proper permissions to do so. In this case a False is returned.</p> <pre><code>await acl.check('campaigns', Roles.MAPPER, Operation.CREATE)\n</code></pre>"},{"location":"schema/","title":"Changing The TM Admin Schema","text":"<p>This document covers how to make changes to the data schemas used in TM Admin, and the changes that were made from the original Tasking Manager (TM). The Field Mapping Tasking Manager (FMTM) database schema was originally based on the TM schema, but doesn't use all the tables, plus added columns. TM Admin has a unified schema that is designed to work with any tasking manager style project.</p>"},{"location":"schema/#the-configuration-file","title":"The configuration file","text":"<p>A simple YAML based config file is used as a single source for all the data structures. This makes it easier to exchange data between postgres, protobuf, and python. The format for configuring a schema is explained in more detail in this document. Any changes to the config file are propogated into the different formats.</p> <p>Updating the config file then requires regenerating all the output files. After any changes to the config files, the test cases should be run to make sure nothing breaks. If the config change is to support a new internal API, then that new function should be added to the test cases.</p>"},{"location":"schema/#merging-tables","title":"Merging Tables","text":"<p>I've been experimenting with the tradeoffs between JSONB columns vs nested tables in Postgres. The current Tasking Manager database schema has multiple small two columns tables, most of those got turned into arrays as I refactoring the schema. But some of the tables in TM are larger like project_team or task_history. Those I had been using as a nested array. The advantages, easy to query, you can see all the columns in each table. Nested tables are being used to reduce needing multiple SQL queries in series to get basic information. The downside is a nested table has to exist in the database when the primary table is created, so there is a dependency problem. It's also a touch confusing, since when you list the tables, you have several of these adding clutter. When doing a bulk insert of multiple tables, it's messy dealing with the dependencies.</p> <p>Since Postgres v12, there are new functions for dealing with JSONB columns that I think make them better than nested tables. A JSONB column doesn't need to be defined ahead of time, it's created dynamically, so also easier to update in the future. They're also fast, JSONB columns have their own index. The downside is the syntax for accessing a JSONB column reminds me of AWK, write-once, difficult to debug. You wind up with SQL like this:</p> <pre><code>SELECT jsonb_path_query(team_members, '$.members[*] ? (@.function[*] == \"MEMBER\" &amp;&amp; @.active==\"false\")') AS player FROM teams WHERE \"id\" = 3;\n</code></pre> <p>I'm burying the SQL queries in a python module, but luckily at one point implementing new queries is mostly cut &amp; paste with minor editing for column names.</p>"},{"location":"schema/#enum-usage","title":"Enum Usage","text":"<p>The current code base for the Tasking Manager defines a bunch of enums, which aren't actually used for database access. This makes the code harder to read as most of the code and the database only use the integer value. This project enforces the use of enums as it makes the code more readable, and more secure. Unfortuantely when using the existing data in the Tasking Manager database, this requires conversion. As a jsonb column may also contain enum values, this requires the data being inserted or updated to loop through all the values to convert them.</p>"},{"location":"schema/#the-types-files","title":"The Types files","text":"<p>All of the enums have been extracted from FMTM and TM, and are defined in the types.yaml file. This file must be processed before all the others, since it defines custom data types all the other files depend on. While the names of the types is the same across platforms, there are minor differences in capitalization which are easily handled.</p>"},{"location":"schema/#types_tmsql","title":"types_tm.sql","text":"<p>This file contains the definitions for postgres. These add new types into postgres, which can then be used by the other tables.</p>"},{"location":"schema/#types_tmpy","title":"types_tm.py","text":"<p>This file contains the definitions for python. These are standard Python IntEnums, so it's possible to get both the name or the numeric value.</p>"},{"location":"schema/#types_tmproto","title":"types_tm.proto","text":"<p>This file contains the protobuf definitions required by gRPC. These are needed to compile any of the other protobuf files.</p>"},{"location":"schema/#regenerating-the-files","title":"Regenerating the files","text":"<p>After any changes to one of the config files, the various output files must be generated. A utility program is included to regenerate all the files, and then updates the database table schemas too. Note that this will wipe any existing data, so is only used to initialize the database.</p> <pre><code>tmadmin-manager.py */*.yaml -v\n</code></pre> <p>If you just want to regenerate the output files to view a change, or work with only one table, use the generate.py program. There is also a base class Generator that can be used by other programs.</p> <pre><code>generate.py users/users.yaml -v\n</code></pre>"},{"location":"schema/#the-python-api","title":"The Python API","text":"<p>There are two python files generated to work with the data structures directly. One is a direct representation of the database table schema. This is in the __class.py_ file. Each one contains a class for each table in the config file. For example, the *users table has a UsersTable class. Each column in the table is a parameter with a default value, so the internal data is the same as the database. The internal data stucture is used throughout TM Admin. When instantiating an instance of this class, any column can be specified as a parameter. This class is used to insert data into the table, to update existing data, or to query data.</p> <pre><code>ut = UsersTable(name='foobar', email_address=\"bar@foo.com\", mapping_level='INTERMEDIATE')\n</code></pre> <p>The other is for managing protobuf messages. As a protobuf message does not contain the full record from the table, these are similar to the *Table class, but just have less fields in the data structure. What is in the protobuf messages is defined in the config file using the share keyword. This is only used to create and parse gRPC messages. Since all the field names between these two classes are the same, it's easy to exchange data.</p>"},{"location":"schema/#importing-data-from-tasking-manager","title":"Importing Data From Tasking Manager","text":"<p>If you have access to an actual postgres database with Tasking Manager data in it, it can be imported into the tm-admin database schema. As the tm-admin schema was originally based on the TM database schema, this is mostly a direct copy. The only major change is in the tasking manager, it only uses the integer value for an array, even when there is a Enum already for this. This project uses the proper enums instead, so some conversion is required.</p> <p>Since the data structure for python is in the types_tm.py file, it's easy to instantiate a class and get the name for the enum from it's integer value.</p> <pre><code>from tm_admin.types_tm import Userrole,\nvalue = 1\nrole = Userrole(value)\nprint(role.name)\n</code></pre>"},{"location":"schema/#importing-the-data","title":"Importing the Data","text":"<p>Data can be imported from a current Tasking Manager into the new database schema. This can be done on a table by table process, or a unified way. There are a few steps to import data from an existing Tasking Manager database into the schema used by TM Admin. The TM Admin schema is a superset, all columns in primary tables are the same in TM and TM Admin. The main differences some of the tables from the Tasking Manager have been incorporated into the primary tables to reduce the amount of database queries required for some of the endpoints.</p> <p>Tasking Manager uses integers for Enum values when accessing the database. TM Admin uses the proper Enum as it makes the code easier to read and also forces all values to be in range. Once the primary table is imported, then each table has to be updated with the small utility tables. Those have all been replaced by using array columns, as most where just two columns anyway. The list of utility tables is covered later in this document.</p> <p>It is assumed the data will only be imported once when upgrading Tasking Manager to a new major version. This is so no data is lost.</p>"},{"location":"schema/#importing-a-table","title":"Importing a Table","text":"<p>To import only one table, initially use the tmdb.py program to import the existing primary table into TM Admin. This only imports a single table without any dependencies.</p> <pre><code>tmdb.py -t users -v\n</code></pre> <p>Some of the primary tables from Tasking Manager have small auxilary tables that then need to be imported. Since importing these updates an existing record instead of inserting it, the primary table's data obviously must be imported first.</p> <p>To import the remaining tables into the array columns or a jsonb column, each base class has support for their format. For example, to import all the utility tables for the primary users table, do this:</p> <pre><code>users/users.py -v\n</code></pre> <p>Note that the base classes have methods for importing everything, so they can be utilized by other programs. The simple terminal based way is of primary interest only to developers.</p>"},{"location":"schema/#importing-everything","title":"Importing everything","text":"<p>While importing single tables is useful for development, most just want to import everything. There is a utility program that does this. Currently this goes through several steps required to setup a database from scratch. This required you have created the database already, but it has no tables defined.</p> <pre><code>    # Generate all language binding files\n    tmadmin_manage.py -v -c generate */*.yaml\n\n    # Create the tables in the database\n    tmadmin_manage.py -v -c create */*.sql\n\n    # Import the data for the all primary tables.\n    tmadmin_manage.py -v -c import\n\n    # Import the data for just the users table\n    tmadmin_manage.py -v -c import users\n</code></pre> <p>The default databases used by this program are tm4 for the existing data, and tm_admin for the new database. This can also be changed using the -i and -o options to this program. There is more detail on the tmadmin-manage.py program on this page.</p>"},{"location":"schema/#default-tables","title":"Default Tables","text":"<p>There are a few support tables that have preset values, like interests or licenses. These are tables in the database because they can be updated by the front end, which we can't do as a Enum. So these are just default values that get indexed by the other tables.</p>"},{"location":"schema/#changes","title":"Changes","text":"<p>The existing TM database schema has been extended multiple times over many years. One common theme is is often has multiple tables for a single record type. Many of these are small, and consist primarily of 2 columns, usually two IDs. For example project_id and user_id. There's much more detail on the existing database schema here.</p>"},{"location":"schema/#user-table","title":"User Table","text":"<p>Rather than have a separate project_favorites table, an array of projects has been added as favorite_projects. Same with the user_interests and user_licenses. user_interests is now an array of interest IDs, and user_licenses is a single integer. The users_with_email columns has been removed as it's possible to just query the database for users with or without email addresses.</p> <p>The users tables also absorbed the team_members table, adding these columns to the users table as a jsonb array. This lets a user have different functions or activity across multiple projects, which is currently not supported by TM.</p> <ul> <li>join_request_notifications</li> <li>team</li> <li>active</li> <li>function</li> </ul>"},{"location":"schema/#projects-table","title":"Projects Table","text":"<p>There's a lot of project related tables.</p> <p>From project_info:</p> <ul> <li>name</li> <li>short_description</li> <li>description</li> <li>instructions</li> </ul> <p>From project_allowed_users table</p> <ul> <li>add to array of users</li> </ul> <p>From project_favorites table</p> <ul> <li>add to array of favorites</li> </ul> <p>From project_interests table</p> <p>Right now a project has a single interest, but it'd be easy to exapand to an array if multiple interest support was wanted.</p> <ul> <li>add integer column</li> </ul> <p>From project_custom_editors table</p> <ul> <li>appears to only be used for Rapid, but it's in the Enum for editors,   so uneeded now</li> </ul> <p>From project_priority_areas tables</p> <ul> <li>add array of priority areas</li> </ul> <p>From project_teams table</p> <ul> <li>Add team_id, team_role to teams jsonb column.</li> </ul>"},{"location":"schema/#organizations-table","title":"Organizations Table","text":"<p>From organisation_managers tables into an array in the organizations table.</p> <ul> <li>Add array of manager's user IDs</li> </ul>"},{"location":"schema/#teams-table","title":"Teams Table","text":"<p>The teams table is based on OSM teams, but has been modified to support any team. Added columns from the team_members to the TM Admin teams jsonb column.</p> <ul> <li>Team ID</li> <li>function (mapper or manager)</li> <li>active</li> </ul> <p>The join_request_notifications column in team_members has been left out as this will be in the notification table.</p>"},{"location":"schema/#tasks-table","title":"Tasks Table","text":"<p>This is obviously a heavily used table, and in the Tasking Manager, is actually 5 tables. The goal here is to merge the tables together using postgres arrays and jsonb columns to reduce the number of sequential queries that need to be made for some API endpoints.</p> <p>This table also has two indexes, as the task ID is not unique across all projects, only within a single project. Both the task ID and project ID need to be used in queries to get the right one.</p> <ul> <li>task_mapping_issues is now an Enum instead of a table</li> </ul>"},{"location":"schema/#task-history-table","title":"Task History Table","text":"<p>The task_history table is now a jsonb column within the tasks table. The id column is no longer needed, and the project_id and task_id are already in the tasks table. In TM the action is a string, which in TM Admin is a proper Enum, which is used instead. The action_text, action_date and user_id are all preserved in the jsonb column. The action is now using an Enum in the code, and the equivalant SQL type everywhere.</p>"},{"location":"schema/#task-mapping-issues","title":"Task Mapping Issues","text":"<p>This table in Tasking Manager must be new, as it contains little data. It's basically a summary of the issue, like \"Missed Features(s)\", or \"Feature Geometry\", with a count of how many features have this issue. I'm not sure the category actually needs to be a column.</p> <p>Currently in the Tasking Manager there is an index into the history table, which no longer exists. So the details of the issue are merged with the issues jsob column. THe only two columns still in use is issue and count.</p> <p>In the Tasking Manager, there is a task status of BADIMAGERY, which has been moved to the Mapping_issue enum, which is more appropriate.</p>"},{"location":"schema/#task-invalidation-history-table","title":"Task Invalidation History Table","text":"<p>This table has been merged into the history as invalidation is an update to the history. Several columns have been dropped as nopw they are unnecessary, id, project_id, task_id. Updated_data seemes like a duplicate, so using the two validate or invalidate dates, since updates change those.</p>"},{"location":"schema/#task-annotations","title":"Task Annotations","text":"<p>This table appears not to be used by TM yet.</p>"},{"location":"schema/#notifications","title":"Notifications","text":"<p>TODO: not implemented yet</p>"},{"location":"schema/#messages","title":"Messages","text":"<p>The messages table is imported with no changes.</p>"},{"location":"schema/#campaigns","title":"Campaigns","text":"<p>Currently in TM, campaigns are implemented as a primary table, and two utility ones. These two utility tables gone in TM Admin, and replaced by an array for each.</p>"},{"location":"schema/#testing-changes","title":"Testing Changes","text":"<p>The code has been designed to be flexible and dynamic. Most of the code extracts the keys &amp; values from the data itself. There is a lot of looping through data structures to keep things self-adjusting.</p> <p>A test suite has been created from the internal APIs used by the backends of TM and FMTM. Many of the API endpoints are for convienince, getting the value of a column from the database, or updating existing data. Some are more functional, accessing one or more tables to produce the correct output. These tests duplicate the lower-level functionality the existing backends require.</p>"},{"location":"structure/","title":"Code Structure","text":"<p>This document is only of use to people considering being part of our development community.</p>"},{"location":"structure/#code-walkthrough","title":"Code walkthrough","text":"<p>This is a short description of the files for this project.</p>"},{"location":"structure/#the-top-level","title":"The Top Level","text":"<p>The top level directory mostly has subdirectories where all the work is done, so this is mostly project management files, like python packaging.</p> <p>The primary directories are:</p> <ul> <li>main/tests - Which contains all the test cases</li> <li>main/docs - Which contains all the documentation</li> <li>main/tm_admin - Which contains all of the code.</li> </ul>"},{"location":"structure/#makefiles","title":"Makefiles","text":"<p>Some directories have a Makefile. This is for automating tasks used by developers. This is common for generating documentation or the other files this project creates. Since Makefiles do dependency tracking, it reduces the amount of files that hace to be regenerated after a change.</p>"},{"location":"structure/#generated-files","title":"Generated Files","text":"<p>This project supports multiple language bindings. These are all configured by the YAML based confg file that defines the data structures. The generator.py program creates the output files from the config file.</p> <p>For example for the users table:</p> <ul> <li>users_class.py - A class that defines the data as a dictionary</li> <li>users.proto.py - The protobuf file for gRPC</li> <li>users_proto.py - A class for accessing protobuf messages</li> </ul>"},{"location":"structure/#adding-a-table","title":"Adding A Table","text":"<p>To add a new database table, create the directory for it, and then create the following 3 files. Rename foo of course.</p> <pre><code>tm_admin/foo/\n    -&gt; api.py\n    -&gt; foo.py\n    -&gt; foo.yaml\n</code></pre> <p>The foo.yaml file defines the data structure for accessing the database. It is required when adding a new table. The foo.py is the one that defines the FooDB class, which is the glue between postgres and this project. The FooDB class contains code for direct table management within the database.</p> <p>The api.py files ia an API for accessing the database for Tasking Manager style projects. This can be incorporated into a FastAPI or Flask backend.</p> <p>The jsonb columns can also defined by a yaml file. This is useful when the josb column has Enum values, as the jsonb columns don't support data types. The generated class file will define a data structure for the column that makes it easy to access each element in the jsonb column with the correct Enum value.</p>"},{"location":"structure/#testing","title":"Testing","text":"<p>All the test cases in the tests directory can be run standalone while debugging them, or via pytest for github. Note that all test cases must support the asyncio API used in the rest of the code.</p>"},{"location":"structure/#api-support","title":"API Support","text":"<p>Each table directory contains an api.py files, which is support code for a website backend. This lets the queries used to support the front end share code with the testsuite. Any function that simply returns data from a query, can be implemented in the calling code. More complex queries that may involve multiple tables, or actions based on the data are in the api.py</p> <p>The primary generated python files contain a class that uses a dictionary to mirror the table schema. Each key in the class maps to a column in the table.</p> <p>For example, the projects_teams.yaml file generates this class for the jsonb column in the projects table:</p> <pre><code>class Projects_teamsTable(object):\n    def __init__(self,\n        team_id: int = None, role: tm_admin.types_tm.Teamroles =\n        tm_admin.types_tm.Teamroles.TEAM_READ_ONLY):\n        self.data = {'team_id': team_id, 'role': role}\n</code></pre> <p>The Table classes are heavily used by the API as a parameter passed to functions, as well as data returned from functions. For example:</p> <pre><code>pt = ProjectsTable(id=0, author_id=1, geometry=geom, centroid=center,\n                    created='2021-12-15 09:58:02.672236',\n                    task_creation_mode='GRID', status='DRAFT',\n                    mapping_level='BEGINNER')\n# returns True or False\nresult = await projects.insertRecords([pt])\n</code></pre>"},{"location":"tmadmin-manage/","title":"TM Admin Manage Util","text":"<p>This utility program is the standalone interface to the tm-admin project. It is responsible for creating the database and the tables, and generating the protobuf files for gRPC.</p> <p>Initially it is used to generate the SQL files for creating the database and it's tables. These are created from a YAML based config file. That file is described in more detail in this document. This same YAML file is also used to generate all the protobuf files that define each gRPC message, and the python wrappers.</p> <p>Once the SQL files have been generated, this program imports them into the database. It can also handle database schema migrations.</p> <pre><code>usage: config [-h] -v -d DIFF -u URI YAML files\noptions:\n-h, --help            show this help message and exit\n-v [VERBOSE], --verbose [VERBOSE] verbose output\n-d DIFF, --diff DIFF  SQL file diff for migrations\n-u URI, --uri URI     Database URI\n</code></pre> <p>The Database URI defaults to localhost/tm_admin.</p>"},{"location":"tmdb/","title":"tmdb.py","text":"<p>This program imports existing data from the HOT Tasking Manager into this modified database schema. This would only be done when preserving data from Tasking Manager v4 to Tasking Manager v5.</p> <pre><code>usage: tmdb.py [-h] [-v [VERBOSE]] [-i INURI] [-o OUTURI] -t TABLE\n\noptions:\n    -h, --help                 show this help message and exit\n    -v, --verbose              verbose output\n    -i INURI, --inuri INURI    The URI string for the TM database\n    -o OUTURI, --outuri OUTURI The URI string for the TM Admin database\n    -t TABLE, --table TABLE    The table to import into\n</code></pre>"},{"location":"tmdb/#example","title":"example","text":"<p>For example, this command will import the data for the messages table, from the datbase localhost/tm4\" into the datbase *localhost/tm_admin.</p> <pre><code>./tmdb.py -v -i localhost/tm4 -o localhost/tm_admin -t messages\n</code></pre>"},{"location":"tmschema/","title":"Tasking Manager Database Schema","text":"<p>The TM database schema has evolved over the years. It is currently implemented using sqlalchmey for the backend.</p>"},{"location":"tmschema/#misc-tables","title":"Misc Tables","text":"<ul> <li>alembic_version - The version of alembic used</li> <li>banner - A list of banners, which doesn't appear to be used anywhere</li> <li>priority_areas - A list of geometries for priority areas</li> <li>release_version - The version of the TM release</li> <li>spatial_ref_sys - Postgis support</li> </ul>"},{"location":"tmschema/#prepopulated-tables","title":"Prepopulated Tables","text":"<p>These tables contain data used by the frontend mostly. These could have been an Enum, but a tables can be updated by the front end, whereas an Enum can't. It does seem entirely possible these could be extended by a project manager, for example, adding a new license.</p> <ul> <li>interests - General mapper interests</li> <li>licenses - Data licenses</li> <li>mapping_issue_categories - Issues with the map data</li> <li>application_keys - Application keys for remote data. This appears to   not be used.</li> </ul>"},{"location":"tmschema/#campaign-tables","title":"Campaign Tables","text":"<p>The campaigns table is for mapping campaigns. A single campaign can involve multiple organizations and TM projects. </p> <ul> <li>campaigns - Primary table</li> <li>campaign_organisations - Utility table to relate organizations with   a campaign</li> <li>campaign_projects - Utility table to relate projects with a campaign</li> </ul>"},{"location":"tmschema/#organization-tables","title":"Organization Tables","text":"<p>This is for an Organization profile.</p> <ul> <li>organisations - Primary table</li> <li>organisation_managers - Utility table to relate managers with an organization</li> </ul>"},{"location":"tmschema/#project-tables","title":"Project Tables","text":"<p>A project is the area to be mapped for the campaign. Each project contains members and teams, which are stored in other tables.</p> <ul> <li>projects - Primary table</li> <li>project_allowed_users - Utility table to relate users to projects</li> <li>project_custom_editors - Utility table to store custom mapping   editors, currently only used by RapidID</li> <li>project_favorites - Utility table to store favorite projects for a user</li> <li>project_info - Details on the project, like the description &amp; instructions</li> <li>project_interests - Utility table to relate projects to interest categories</li> <li>project_priority_areas - Utility table to relate priority areas to projects</li> <li>project_teams - Utility table to relate team roles to projects</li> <li>project_chat - Support commenting for a project</li> </ul>"},{"location":"tmschema/#messages-table","title":"Messages Table","text":"<p>Support messaging between users.</p> <ul> <li>messages - Primary table</li> </ul>"},{"location":"tmschema/#task-tables","title":"Task Tables","text":"<p>A task is the area for a mapper to map. Task management is obviously a key function of the Tasking Manager.</p> <ul> <li>tasks - Primary table</li> <li>task_annotations - Utility table for something, it appears to be   unused anywhere</li> <li>task_history - Table for task history</li> <li>task_invalidation_history - Table for task invalidation history</li> <li>task_mapping_issues - Table for issues with a task</li> </ul>"},{"location":"tmschema/#task-history-table","title":"Task History Table","text":"<p>This table is used to track the state changes for a task, not including a task being invalidated. It contains a description of the status change, when it changed, and the user ID when the task is locked for mapping. A single task for a project may go through several state changes during it's lifespan.</p>"},{"location":"tmschema/#task-invalidation-history-table","title":"Task Invalidation History Table","text":"<p>This table is used to track tasks that are invalidated. Unlike simple state changes in the task history table, this tracks which validator invalidated the task, when it was invalidated, and when the issue is resolved.</p>"},{"location":"tmschema/#task-mapping-issues","title":"Task Mapping Issues","text":"<p>TBD</p>"},{"location":"tmschema/#team-tables","title":"Team Tables","text":"<p>This is for OSM Team support.</p> <ul> <li>teams - Primary table</li> <li>team_members - Utility table for team member profiles</li> </ul>"},{"location":"tmschema/#user-tables","title":"User Tables","text":"<ul> <li>users - Primary table</li> <li>user_interests - Utility table to relate interests for a user</li> <li>user_licenses - Utility table to relate the data license to user</li> <li>users_with_email - Utility table of user email addresses, which   appears to be unused</li> </ul>"},{"location":"tmschema/#notification-table","title":"Notification Table","text":"<p>This is a simple system for notifications. </p> <ul> <li>notifications - Primary table</li> </ul>"},{"location":"wiki_redirect/","title":"TM Admin","text":"<p>Please see the docs page at: https://hotosm.github.io/tm-admin/</p>"},{"location":"api/campaigns/","title":"Campaigns Table","text":""},{"location":"api/campaigns/#campaignscampaignspy","title":"campaigns/campaigns.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/campaigns/#tm_admin.campaigns.campaigns.CampaignsDB","title":"CampaignsDB","text":"<pre><code>CampaignsDB(dburi='localhost/tm_admin')\n</code></pre> <p>             Bases: <code>DBSupport</code></p> <p>Parameters:</p> Name Type Description Default <code>dburi</code> <code>str</code> <p>The URI string for the database connection</p> <code>'localhost/tm_admin'</code> <p>Returns:</p> Type Description <code>UsersDB</code> <p>An instance of this class</p> Source code in <code>tm_admin/campaigns/campaigns.py</code> <pre><code>def __init__(self,\n             dburi: str = \"localhost/tm_admin\",\n            ):\n    \"\"\"\n    A class to access the campaigns table.\n\n    Args:\n        dburi (str): The URI string for the database connection\n\n    Returns:\n        (UsersDB): An instance of this class\n    \"\"\"\n    self.pg = None\n    self.profile = UsersTable()\n    self.types = dir(tm_admin.types_tm)\n    super().__init__('campaigns')\n</code></pre>"},{"location":"api/campaigns/#tm_admin.campaigns.campaigns.CampaignsDB.mergeOrganizations","title":"mergeOrganizations  <code>async</code>","text":"<pre><code>mergeOrganizations(inpg)\n</code></pre> <p>A method to merge the contents of the TM campaign_organizations into the campaigns table as an array.</p> <p>Parameters:</p> Name Type Description Default <code>inpg</code> <code>PostgresClient</code> <p>The input database</p> required Source code in <code>tm_admin/campaigns/campaigns.py</code> <pre><code>async def mergeOrganizations(self,\n                    inpg: PostgresClient,\n                    ):\n    \"\"\"\n    A method to merge the contents of the TM campaign_organizations into\n    the campaigns table as an array.\n\n    Args:\n        inpg (PostgresClient): The input database\n    \"\"\"\n    # FIXME: this is a weird table, and only has 4 entries, none of which appear\n    # to be in the other tables, so nothing updates.\n    table = 'campaign_organisations'\n    sql = f\"SELECT * FROM {table} ORDER BY campaign_id\"\n    # print(sql)\n    result = await inpg.execute(sql)\n\n    data = dict()\n    pbar = tqdm.tqdm(result)\n    for record in result:\n        sql = f\" UPDATE campaigns SET organizations = organizations||{record['organisation_id']} WHERE id={record['campaign_id']};\"\n        # print(sql)\n        await self.pg.execute(sql)\n</code></pre>"},{"location":"api/campaigns/#tm_admin.campaigns.campaigns.CampaignsDB.mergeProjects","title":"mergeProjects  <code>async</code>","text":"<pre><code>mergeProjects(inpg)\n</code></pre> <p>A method to merge the contents of the TM campaign_projects into the campaigns table as an array.</p> <p>Parameters:</p> Name Type Description Default <code>inpg</code> <code>PostgresClient</code> <p>The input database</p> required Source code in <code>tm_admin/campaigns/campaigns.py</code> <pre><code>async def mergeProjects(self,\n                    inpg: PostgresClient,\n                    ):\n    \"\"\"\n    A method to merge the contents of the TM campaign_projects into\n    the campaigns table as an array.\n\n    Args:\n        inpg (PostgresClient): The input database\n    \"\"\"\n    table = 'campaign_projects'\n    sql = f\"SELECT * FROM {table} ORDER BY campaign_id\"\n    # print(sql)\n    result = await inpg.execute(sql)\n\n    index = 0\n    data = dict()\n    pbar = tqdm.tqdm(result)\n\n    for record in pbar:\n        sql = f\" UPDATE campaigns SET projects = projects||{record['project_id']} WHERE id={record['campaign_id']};\"\n        # print(sql)\n        await self.pg.execute(sql)\n</code></pre>"},{"location":"api/campaigns/#tm_admin.campaigns.campaigns.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/campaigns/campaigns.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-i\", \"--inuri\", default='localhost/tm4',\n                            help=\"Input database URI\")\n    parser.add_argument(\"-o\", \"--outuri\", default='localhost/tm_admin',\n                            help=\"Output database URI\")\n    # parser.add_argument(\"-r\", \"--reset\", help=\"Reset Sequences\")\n    args = parser.parse_args()\n\n    # if len(argv) &lt;= 1:\n    #     parser.print_help()\n    #     quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    inpg = PostgresClient()\n    await inpg.connect(args.inuri)\n\n    camp = camp = CampaignsDB(args.inuri)\n    await camp.connect(args.outuri)\n\n    await camp.mergeProjects(inpg)\n    await camp.mergeOrganizations(inpg)\n</code></pre>"},{"location":"api/campaigns/#campaignscampaigns_classpy","title":"campaigns/campaigns_class.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/campaigns/#campaignsapipy","title":"campaigns/api.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/campaigns/#tm_admin.campaigns.api.CampaignsAPI","title":"CampaignsAPI","text":"<pre><code>CampaignsAPI()\n</code></pre> <p>             Bases: <code>PGSupport</code></p> <p>Returns:</p> Type Description <code>CampaignsAPI</code> <p>An instance of this class</p> Source code in <code>tm_admin/campaigns/api.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Create a class to handle the backend API calls, so the code can be shared\n    between test cases and the actual code.\n\n    Returns:\n        (CampaignsAPI): An instance of this class\n    \"\"\"\n    # self.allowed_roles = [\n    #     Teamrole.TEAM_MAPPER,\n    #     Teamrole.TEAM_VALIDATOR,\n    #     Teamrole.TEAM_MANAGER,\n    # ]\n    # self.messagesdb = MessagesDB()\n    # self.usersdb = UsersDB()\n    # self.teamsdb = TeamsDB()\n    super().__init__(\"campaigns\")\n</code></pre>"},{"location":"api/campaigns/#tm_admin.campaigns.api.CampaignsAPI.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize(inuri)\n</code></pre> <p>Connect to all tables for API endpoints that require accessing multiple tables.</p> <p>Parameters:</p> Name Type Description Default <code>inuri</code> <code>str</code> <p>The URI for the TM Admin output database</p> required Source code in <code>tm_admin/campaigns/api.py</code> <pre><code>async def initialize(self,\n                  inuri: str,\n                  ):\n    \"\"\"\n    Connect to all tables for API endpoints that require\n    accessing multiple tables.\n\n    Args:\n        inuri (str): The URI for the TM Admin output database\n    \"\"\"\n    await self.connect(inuri)\n    await self.getTypes(\"campaigns\")\n</code></pre>"},{"location":"api/campaigns/#tm_admin.campaigns.api.CampaignsAPI.getByID","title":"getByID  <code>async</code>","text":"<pre><code>getByID(campaign_id)\n</code></pre> <p>Get all the information for an campaign using it's ID</p> <p>Parameters:</p> Name Type Description Default <code>campaign_id</code> <code>int</code> <p>The campaign to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the campaign information</p> Source code in <code>tm_admin/campaigns/api.py</code> <pre><code>async def getByID(self,\n                 campaign_id: int,\n                ):\n    \"\"\"\n    Get all the information for an campaign using it's ID\n\n    Args:\n        campaign_id (int): The campaign to get the data for\n\n    Returns:\n        (dict): the campaign information\n    \"\"\"\n    # log.debug(f\"--- getByID() ---\")\n    sql = f\"SELECT * FROM campaigns WHERE id={campaign_id}\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/campaigns/#tm_admin.campaigns.api.CampaignsAPI.getByName","title":"getByName  <code>async</code>","text":"<pre><code>getByName(name)\n</code></pre> <p>Get all the information for a campaign using the name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The campaign to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the campaign information</p> Source code in <code>tm_admin/campaigns/api.py</code> <pre><code>async def getByName(self,\n                    name: str,\n                    ):\n    \"\"\"\n    Get all the information for a campaign using the name\n\n    Args:\n        name (str): The campaign to get the data for\n\n    Returns:\n        (dict): the campaign information\n    \"\"\"\n    # log.debug(f\"--- getByName() ---\")\n    sql = f\"SELECT * FROM campaigns WHERE name='{name}'\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/campaigns/#tm_admin.campaigns.api.CampaignsAPI.create","title":"create  <code>async</code>","text":"<pre><code>create(campaign)\n</code></pre> <p>Create a campaign and add it to the database.</p> <p>Parameters:</p> Name Type Description Default <code>campaign</code> <code>CampaignsTable</code> <p>The team data</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the campaign got created</p> Source code in <code>tm_admin/campaigns/api.py</code> <pre><code>async def create(self,\n                 campaign: CampaignsTable,\n                 ):\n    \"\"\"\n    Create a campaign and add it to the database.\n\n    Args:\n        campaign (CampaignsTable): The team data\n\n    Returns:\n        (bool): Whether the campaign got created\n    \"\"\"\n    # log.warning(f\"create(): unimplemented!\")\n    result = await self.insertRecords([campaign])\n\n    # The ID of the record that just got inserted is returned\n    if result:\n        return True\n\n    return False\n</code></pre>"},{"location":"api/campaigns/#tm_admin.campaigns.api.CampaignsAPI.update","title":"update  <code>async</code>","text":"<pre><code>update(campaign)\n</code></pre> <p>Update a campaign that is already in the database.</p> <p>Parameters:</p> Name Type Description Default <code>campaign</code> <code>CampaignsTable</code> <p>The campaign data</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the campaign got updated</p> Source code in <code>tm_admin/campaigns/api.py</code> <pre><code>async def update(self,\n                 campaign: CampaignsTable,\n                 ):\n    \"\"\"\n    Update a campaign that is already in the database.\n\n    Args:\n        campaign (CampaignsTable): The campaign data\n\n    Returns:\n        (bool): Whether the campaign got updated\n    \"\"\"\n    log.warning(f\"update(): unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/campaigns/#tm_admin.campaigns.api.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/campaigns/api.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-u\", \"--uri\", default='localhost/tm_admin', help=\"Database URI\")\n\n    args = parser.parse_args()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n</code></pre>"},{"location":"api/messages/","title":"Messages Table","text":""},{"location":"api/messages/#messagesmessagespy","title":"messages/messages.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/messages/#tm_admin.messages.messages.MessagesDB","title":"MessagesDB","text":"<pre><code>MessagesDB(dburi='localhost/tm_admin')\n</code></pre> <p>             Bases: <code>DBSupport</code></p> <p>Parameters:</p> Name Type Description Default <code>dburi</code> <code>str</code> <p>The URI string for the database connection</p> <code>'localhost/tm_admin'</code> <p>Returns:</p> Type Description <code>MessagesDB</code> <p>An instance of this class</p> Source code in <code>tm_admin/messages/messages.py</code> <pre><code>def __init__(self,\n             dburi: str = \"localhost/tm_admin\",\n            ):\n    \"\"\"\n    A class to access the messages table.\n\n    Args:\n        dburi (str): The URI string for the database connection\n\n    Returns:\n        (MessagesDB): An instance of this class\n    \"\"\"\n    self.pg = None\n    self.profile = MessagesTable()\n    self.types = dir(tm_admin.types_tm)\n    super().__init__('messages')\n</code></pre>"},{"location":"api/messages/#tm_admin.messages.messages.MessagesDB.getByFilter","title":"getByFilter","text":"<pre><code>getByFilter(\n    user_id,\n    locale,\n    page,\n    page_size=10,\n    sort_by=None,\n    sort_direction=None,\n    message_type=None,\n    from_username=None,\n    project=None,\n    task_id=None,\n    status=None,\n)\n</code></pre> <p>Filter Args:     msg (MessagesTable): The filter criteria</p> <p>Returns:</p> Type Description <code>list</code> <p>the messages that match the filter</p> Source code in <code>tm_admin/messages/messages.py</code> <pre><code>def getByFilter(self,\n                user_id: int,\n                locale: str,\n                page: int,\n                page_size = 10,\n                sort_by = None,\n                sort_direction = None,\n                message_type = None,\n                from_username = None,\n                project = None,\n                task_id = None,\n                status = None,\n                ):\n    \"\"\"\n    Filter\n    Args:\n        msg (MessagesTable): The filter criteria\n\n    Returns:\n        (list): the messages that match the filter\n    \"\"\"\n    if sort_column is None:\n        pass\n    if project is not None:\n        pass\n    if task_id is not None:\n        pass\n    if status in [\"read\", \"unread\"]:\n        pass\n    if message_type:\n        pass\n    if from_username is not None:\n        pass\n</code></pre>"},{"location":"api/messages/#tm_admin.messages.messages.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/messages/messages.py</code> <pre><code>def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-u\", \"--uri\", default='localhost/tm_admin', help=\"Database URI\")\n    # parser.add_argument(\"-r\", \"--reset\", help=\"Reset Sequences\")\n    args = parser.parse_args()\n\n    # if len(argv) &lt;= 1:\n    #     parser.print_help()\n    #     quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    message = MessagesDB(args.uri)\n</code></pre>"},{"location":"api/messages/#messagesmessages_classpy","title":"messages/messages_class.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/messages/#messagesapipy","title":"messages/api.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/messages/#tm_admin.messages.api.MessagesAPI","title":"MessagesAPI","text":"<pre><code>MessagesAPI()\n</code></pre> <p>             Bases: <code>PGSupport</code></p> <p>Returns:</p> Type Description <code>MessagesAPI</code> <p>An instance of this class</p> Source code in <code>tm_admin/messages/api.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Create a class to handle the backend API calls, so the code can be shared\n    between test cases and the actual code.\n\n    Returns:\n        (MessagesAPI): An instance of this class\n    \"\"\"\n    # self.messagesdb = MessagesDB()\n    # self.usersdb = UsersDB()\n    # self.teamsdb = TeamsDB()\n\n    super().__init__(\"campaigns\")\n</code></pre>"},{"location":"api/messages/#tm_admin.messages.api.MessagesAPI.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize(inuri)\n</code></pre> <p>Connect to all tables for API endpoints that require accessing multiple tables.</p> <p>Parameters:</p> Name Type Description Default <code>inuri</code> <code>str</code> <p>The URI for the TM Admin output database</p> required Source code in <code>tm_admin/messages/api.py</code> <pre><code>async def initialize(self,\n                  inuri: str,\n                  ):\n    \"\"\"\n    Connect to all tables for API endpoints that require\n    accessing multiple tables.\n\n    Args:\n        inuri (str): The URI for the TM Admin output database\n    \"\"\"\n    await self.connect(inuri)\n    await self.getTypes(\"messages\")\n</code></pre>"},{"location":"api/messages/#tm_admin.messages.api.MessagesAPI.getByID","title":"getByID  <code>async</code>","text":"<pre><code>getByID(message_id)\n</code></pre> <p>Get all the information for an message using it's ID</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>int</code> <p>The message to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the message information</p> Source code in <code>tm_admin/messages/api.py</code> <pre><code>async def getByID(self,\n                 message_id: int,\n                ):\n    \"\"\"\n    Get all the information for an message using it's ID\n\n    Args:\n        message_id (int): The message to get the data for\n\n    Returns:\n        (dict): the message information\n    \"\"\"\n    # log.debug(f\"--- getByID() ---\")\n    sql = f\"SELECT * FROM messages WHERE id={org_id}\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/messages/#tm_admin.messages.api.MessagesAPI.getByName","title":"getByName  <code>async</code>","text":"<pre><code>getByName(name)\n</code></pre> <p>Get all the information for a message using the name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The message to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the message information</p> Source code in <code>tm_admin/messages/api.py</code> <pre><code>async def getByName(self,\n                    name: str,\n                    ):\n    \"\"\"\n    Get all the information for a message using the name\n\n    Args:\n        name (str): The message to get the data for\n\n    Returns:\n        (dict): the message information\n    \"\"\"\n    # log.debug(f\"--- getByName() ---\")\n    sql = f\"SELECT * FROM messages WHERE name='{name}'\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/messages/#tm_admin.messages.api.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/messages/api.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-u\", \"--uri\", default='localhost/tm_admin', help=\"Database URI\")\n\n    args = parser.parse_args()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n</code></pre>"},{"location":"api/organizations/","title":"Organizations Table","text":""},{"location":"api/organizations/#organizationspy","title":"organizations.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/organizations/#tm_admin.organizations.organizations.OrganizationsDB","title":"OrganizationsDB","text":"<pre><code>OrganizationsDB(dburi='localhost/tm_admin')\n</code></pre> <p>             Bases: <code>DBSupport</code></p> <p>Parameters:</p> Name Type Description Default <code>dburi</code> <code>str</code> <p>The URI string for the database connection</p> <code>'localhost/tm_admin'</code> <p>Returns:</p> Type Description <code>OrganizationsDB</code> <p>An instance of this class</p> Source code in <code>tm_admin/organizations/organizations.py</code> <pre><code>def __init__(self,\n             dburi: str = \"localhost/tm_admin\",\n            ):\n    \"\"\"\n    A class to access the organizations table.\n\n    Args:\n        dburi (str): The URI string for the database connection\n\n    Returns:\n        (OrganizationsDB): An instance of this class\n    \"\"\"\n    self.pg = None\n    self.profile = OrganizationsTable()\n    self.types = dir(tm_admin.types_tm)\n    super().__init__('organizations')\n</code></pre>"},{"location":"api/organizations/#tm_admin.organizations.organizations.OrganizationsDB.mergeManagers","title":"mergeManagers  <code>async</code>","text":"<pre><code>mergeManagers(inpg)\n</code></pre> <p>A method to merge the contents of the TM organisation_managers into the orgsanizations table as an array.</p> <p>Parameters:</p> Name Type Description Default <code>inpg</code> <code>PostgresClient</code> <p>The input database</p> required Source code in <code>tm_admin/organizations/organizations.py</code> <pre><code>async def mergeManagers(self,\n                    inpg: PostgresClient,\n                    ):\n    \"\"\"\n    A method to merge the contents of the TM organisation_managers into\n    the orgsanizations table as an array.\n\n    Args:\n        inpg (PostgresClient): The input database\n    \"\"\"\n    # FIXME: this is a weird table, and only has 4 entries, none of which appear\n    # to be in the other tables, so nothing updates.\n    table = 'organisation_managers'\n    sql = f\"SELECT * FROM {table} ORDER BY organisation_id\"\n    # print(sql)\n    result = await inpg.execute(sql)\n\n    data = dict()\n    pbar = tqdm.tqdm(result)\n    for record in result:\n        sql = f\" UPDATE organizations SET managers = managers||{record['user_id']} WHERE id={record['organisation_id']};\"\n        # print(sql)\n        await self.pg.execute(sql)\n</code></pre>"},{"location":"api/organizations/#tm_admin.organizations.organizations.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/organizations/organizations.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-i\", \"--inuri\", default='localhost/tm4',\n                            help=\"Input database URI\")\n    parser.add_argument(\"-o\", \"--outuri\", default='localhost/tm_admin',\n                            help=\"Output database URI\")\n    # parser.add_argument(\"-r\", \"--reset\", help=\"Reset Sequences\")\n    args = parser.parse_args()\n\n    # if len(argv) &lt;= 1:\n    #     parser.print_help()\n    #     quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    inpg = PostgresClient()\n    await inpg.connect(args.inuri)\n\n    org = OrganizationsDB()\n    await org.connect(args.outuri)\n\n    await org.mergeManagers(inpg)\n</code></pre>"},{"location":"api/organizations/#organizations_classpy","title":"organizations_class.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/organizations/#organizationsapipy","title":"organizations/api.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/organizations/#tm_admin.organizations.api.OrganizationsAPI","title":"OrganizationsAPI","text":"<pre><code>OrganizationsAPI()\n</code></pre> <p>             Bases: <code>PGSupport</code></p> <p>Returns:</p> Type Description <code>OrganizationsAPI</code> <p>An instance of this class</p> Source code in <code>tm_admin/organizations/api.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Create a class to handle the backend API calls, so the code can be shared\n    between test cases and the actual code.\n\n    Returns:\n        (OrganizationsAPI): An instance of this class\n    \"\"\"\n    self.orgdb = OrganizationsDB()\n    super().__init__(\"organizations\")\n</code></pre>"},{"location":"api/organizations/#tm_admin.organizations.api.OrganizationsAPI.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize(inuri)\n</code></pre> <p>Connect to all tables for API endpoints that require accessing multiple tables.</p> <p>Parameters:</p> Name Type Description Default <code>inuri</code> <code>str</code> <p>The URI for the TM Admin output database</p> required Source code in <code>tm_admin/organizations/api.py</code> <pre><code>async def initialize(self,\n                  inuri: str,\n                  ):\n    \"\"\"\n    Connect to all tables for API endpoints that require\n    accessing multiple tables.\n\n    Args:\n        inuri (str): The URI for the TM Admin output database\n    \"\"\"\n    await self.connect(inuri)\n    await self.getTypes(\"organizations\")\n</code></pre>"},{"location":"api/organizations/#tm_admin.organizations.api.OrganizationsAPI.getByID","title":"getByID  <code>async</code>","text":"<pre><code>getByID(org_id)\n</code></pre> <p>Get all the information for an organization using it's ID</p> <p>Parameters:</p> Name Type Description Default <code>org_id</code> <code>int</code> <p>The organization to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the organization information</p> Source code in <code>tm_admin/organizations/api.py</code> <pre><code>async def getByID(self,\n                 org_id: int,\n                ):\n    \"\"\"\n    Get all the information for an organization using it's ID\n\n    Args:\n        org_id (int): The organization to get the data for\n\n    Returns:\n        (dict): the organization information\n    \"\"\"\n    # log.debug(f\"--- getByID() ---\")\n    sql = f\"SELECT * FROM organizations WHERE id={org_id}\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/organizations/#tm_admin.organizations.api.OrganizationsAPI.getByName","title":"getByName  <code>async</code>","text":"<pre><code>getByName(name)\n</code></pre> <p>Get all the information for a organization using the name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The organization to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the organization information</p> Source code in <code>tm_admin/organizations/api.py</code> <pre><code>async def getByName(self,\n                    name: str,\n                    ):\n    \"\"\"\n    Get all the information for a organization using the name\n\n    Args:\n        name (str): The organization to get the data for\n\n    Returns:\n        (dict): the organization information\n    \"\"\"\n    # log.debug(f\"--- getByName() ---\")\n    sql = f\"SELECT * FROM organization WHERE name='{name}'\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/organizations/#tm_admin.organizations.api.OrganizationsAPI.getStats","title":"getStats  <code>async</code>","text":"<pre><code>getStats(org_id)\n</code></pre> <p>Args:</p> <p>Returns:</p> Source code in <code>tm_admin/organizations/api.py</code> <pre><code>async def getStats(self,\n                   org_id: int,\n                   ):\n    \"\"\"\n\n    Args:\n\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"getStats(): unimplemented!\")\n</code></pre>"},{"location":"api/organizations/#tm_admin.organizations.api.OrganizationsAPI.validateName","title":"validateName  <code>async</code>","text":"<pre><code>validateName(name)\n</code></pre> <p>Args:</p> <p>Returns:</p> Source code in <code>tm_admin/organizations/api.py</code> <pre><code>async def validateName(self,\n                       name: str,\n                       ):\n    \"\"\"\n\n    Args:\n\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"validateName(): unimplemented!\")\n</code></pre>"},{"location":"api/organizations/#tm_admin.organizations.api.OrganizationsAPI.validateUser","title":"validateUser  <code>async</code>","text":"<pre><code>validateUser(name)\n</code></pre> <p>Args:</p> <p>Returns:</p> Source code in <code>tm_admin/organizations/api.py</code> <pre><code>async def validateUser(self,\n                       name: str,\n                       ):\n    \"\"\"\n\n    Args:\n\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"validateName(): unimplemented!\")\n</code></pre>"},{"location":"api/organizations/#tm_admin.organizations.api.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/organizations/api.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-u\", \"--uri\", default='localhost/testdata', help=\"Database URI\")\n\n    args = parser.parse_args()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n</code></pre>"},{"location":"api/projects/","title":"Projects Table","text":""},{"location":"api/projects/#projectsprojectspy","title":"projects/projects.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/projects/#tm_admin.projects.projects.ProjectsDB","title":"ProjectsDB","text":"<pre><code>ProjectsDB(dburi='localhost/tm_admin')\n</code></pre> <p>             Bases: <code>DBSupport</code></p> <p>Parameters:</p> Name Type Description Default <code>dburi</code> <code>str</code> <p>The URI string for the database connection</p> <code>'localhost/tm_admin'</code> <p>Returns:</p> Type Description <code>ProjectsDB</code> <p>An instance of this class</p> Source code in <code>tm_admin/projects/projects.py</code> <pre><code>def __init__(self,\n             dburi: str = \"localhost/tm_admin\",\n            ):\n    \"\"\"\n    A class to access the projects table.\n\n    Args:\n        dburi (str): The URI string for the database connection\n\n    Returns:\n        (ProjectsDB): An instance of this class\n    \"\"\"\n    self.pg = None\n    self.profile = ProjectsTable()\n    self.types = dir(tm_admin.types_tm)\n    super().__init__('projects')\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.projects.ProjectsDB.mergeAuxTables","title":"mergeAuxTables  <code>async</code>","text":"<pre><code>mergeAuxTables(inuri, outuri)\n</code></pre> <p>Merge more tables from TM into the unified projects table.</p> <p>Parameters:</p> Name Type Description Default <code>inuri</code> <code>str</code> <p>The input database</p> required <code>outuri</code> <code>str</code> <p>The output database</p> required Source code in <code>tm_admin/projects/projects.py</code> <pre><code>async def mergeAuxTables(self,\n                         inuri: str,\n                         outuri: str,\n                         ):\n    \"\"\"\n    Merge more tables from TM into the unified projects table.\n\n    Args:\n        inuri (str): The input database\n        outuri (str): The output database\n    \"\"\"\n    await self.connect(outuri)\n\n    inpg = PostgresClient()\n    await inpg.connect(inuri)\n\n    await self.mergeAllowed(inpg)\n\n    await self.mergeTeams(inpg)\n\n    await self.mergeInfo(inpg)\n\n    await self.mergeChat(inpg)\n\n    await self.mergeInterests(inpg)\n\n    await self.mergePriorities(inpg)\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.projects.updateThread","title":"updateThread  <code>async</code>","text":"<pre><code>updateThread(queries, db)\n</code></pre> <p>Thread to handle importing data</p> <p>Parameters:</p> Name Type Description Default <code>queries</code> <code>list</code> <p>The list of SQL queries to execute</p> required <code>db</code> <code>PostgresClient</code> <p>A database connection</p> required Source code in <code>tm_admin/projects/projects.py</code> <pre><code>async def updateThread(\n    queries: list,\n    db: PostgresClient,\n):\n    \"\"\"Thread to handle importing data\n\n    Args:\n        queries (list): The list of SQL queries to execute\n        db (PostgresClient): A database connection\n    \"\"\"\n    pbar = tqdm.tqdm(queries)\n    # for sql in queries:\n    for sql in pbar:\n        # print(sql)\n        result = await db.execute(sql)\n\n    return True\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.projects.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/projects/projects.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-i\", \"--inuri\", default='localhost/tm4',\n                            help=\"Database URI\")\n    parser.add_argument(\"-o\", \"--outuri\", default='localhost/tm_admin',\n                            help=\"Database URI\")\n    parser.add_argument(\"-b\", \"--boundary\", help=\"The project AOI\")\n\n    # parser.add_argument(\"-r\", \"--reset\", help=\"Reset Sequences\")\n    args = parser.parse_args()\n\n    # if len(argv) &lt;= 1:\n    #     parser.print_help()\n    #     quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    proj = ProjectsDB(args.outuri)\n    # user.resetSequence()\n    #all = proj.getAll()\n\n    timer = Timer(initial_text=f\"Merging all other tables...\",\n                      text=\"Importing took {seconds:.0f}s\",\n                      logger=log.debug,\n                    )\n    timer.start()\n    await proj.mergeAuxTables(args.inuri, args.outuri)\n    timer.stop()\n</code></pre>"},{"location":"api/projects/#projectsprojects_classpy","title":"projects/projects_class.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/projects/#projectsapipy","title":"projects/api.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI","title":"ProjectsAPI","text":"<pre><code>ProjectsAPI()\n</code></pre> <p>             Bases: <code>PGSupport</code></p> <p>Returns:</p> Type Description <code>ProjectsAPI</code> <p>An instance of this class</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Create a class to handle the backend API calls, so the code can be shared\n    between test cases and the actual code.\n\n    Returns:\n        (ProjectsAPI): An instance of this class\n    \"\"\"\n    self.allowed_roles = [\n        Teamrole.TEAM_MAPPER,\n        Teamrole.TEAM_VALIDATOR,\n        Teamrole.TEAM_MANAGER,\n    ]\n    from tm_admin.users.api import UsersAPI\n    self.users = None\n    self.tasks = None\n    super().__init__(\"projects\")\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize(inuri)\n</code></pre> <p>Connect to all tables for API endpoints that require accessing multiple tables.</p> <p>Parameters:</p> Name Type Description Default <code>inuri</code> <code>str</code> <p>The URI for the TM Admin output database</p> required Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def initialize(self,\n                     inuri: str,\n                  ) -&gt; None:\n    \"\"\"\n    Connect to all tables for API endpoints that require accessing multiple tables.\n\n    Args:\n        inuri (str): The URI for the TM Admin output database\n    \"\"\"\n    await self.connect(inuri)\n    await self.getTypes(\"projects\")\n    self.users = tm_admin.users.api.UsersAPI()\n    self.tasks = tm_admin.tasks.api.TasksAPI()\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.getByID","title":"getByID  <code>async</code>","text":"<pre><code>getByID(project_id)\n</code></pre> <p>Get all the information for a project using it's ID</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The team to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the project information</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def getByID(self,\n                 project_id: int,\n                ):\n    \"\"\"\n    Get all the information for a project using it's ID\n\n    Args:\n        project_id (int): The team to get the data for\n\n    Returns:\n        (dict): the project information\n    \"\"\"\n    log.debug(f\"--- getByID() ---\")\n    sql = f\"SELECT * FROM projects WHERE id={project_id}\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.getTeamRole","title":"getTeamRole  <code>async</code>","text":"<pre><code>getTeamRole(project_id, team_id)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>id</code> <p>The project ID</p> required <code>team_id</code> <code>id</code> <p>The team ID</p> required <p>Returns:</p> Type Description <code>Teamrole</code> <p>The role of this team in this project</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def getTeamRole(self,\n                    project_id: int,\n                    team_id: int,\n                    ):\n    \"\"\"\n    Args:\n        project_id (id): The project ID\n        team_id (id): The team ID\n\n    Returns:\n        (Teamrole): The role of this team in this project\n    \"\"\"\n    # log.warning(f\"getProjectByTeam(): unimplemented!\")\n    # sql = f\"SELECT FROM projects WHERE project_id={project_id}\"\n    # where = [{'teams': {\"team_id\": team_id, \"project_id\": project_id}}]\n    #data = await self.getColumns(['id', 'teams'], where)\n    # The role is in a list of dicts in a jsonb column.\n\n    sql = f\"SELECT jsonb_path_query(teams, '$.teams[*] ? (@.team_id[*] == {team_id})') AS results FROM projects WHERE id = {project_id};\"\n    results = await self.execute(sql)\n\n    # There should only be one item in the results. Since it's a jsonb column\n    # the data is returned as a string. In the string is an enum value, which\n    # gets converted to the actual enum for Teamrole.\n    if len(results) &gt; 0:\n        if results[0]['results'][0] == '{':\n            tmp1 = eval(results[0]['results'])\n            tmp2 = f\"Teamrole.{tmp1['role']}\"\n            role = eval(tmp2)\n            return role\n\n    # we should never get here, but you never know...\n        return None\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.getByName","title":"getByName  <code>async</code>","text":"<pre><code>getByName(name)\n</code></pre> <p>Get all the information for a project using the name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The project to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the project information</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def getByName(self,\n                    name: str,\n                    ):\n    \"\"\"\n    Get all the information for a project using the name\n\n    Args:\n        name (str): The project to get the data for\n\n    Returns:\n        (dict): the project information\n    \"\"\"\n    log.debug(f\"--- getByName() ---\")\n    sql = f\"SELECT * FROM projects WHERE name='{name}'\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.changeStatus","title":"changeStatus  <code>async</code>","text":"<pre><code>changeStatus(project_id, status)\n</code></pre> <p>Manage the status of a task. This would be locking or unlocking, validation status, etc...</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The project ID to change</p> required <code>status</code> <code>ProjectStatus</code> <p>The status to change to</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether locking/unlocking the task was sucessful</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def changeStatus(self,\n                    project_id: int,\n                    status: Projectstatus,\n                    ):\n    \"\"\"\n    Manage the status of a task. This would be locking or unlocking,\n    validation status, etc...\n\n    Args:\n        project_id (int): The project ID to change\n        status (ProjectStatus): The status to change to\n\n    Returns:\n        (bool): Whether locking/unlocking the task was sucessful\n    \"\"\"\n    log.warning(f\"changeStatus(): unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.evaluateMappingPermissions","title":"evaluateMappingPermissions  <code>async</code>","text":"<pre><code>evaluateMappingPermissions(uid, pid, perm)\n</code></pre> <p>evaluate_mapping_permission()</p> <p>Parameters:</p> Name Type Description Default <code>uid</code> <code>int</code> <p>The user ID</p> required <code>pid</code> <code>int</code> <p>The project ID</p> required <code>perm</code> <code>Permissions</code> <p>The permission level to check against</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If the user has the right permissions for this project</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def evaluateMappingPermissions(self,\n                               uid: int,\n                               pid: int,\n                               perm: Permissions,\n                               ):\n    \"\"\"\n    evaluate_mapping_permission()\n\n    Args:\n        uid (int): The user ID\n        pid (int): The project ID\n        perm (Permissions): The permission level to check against\n\n    Returns:\n        (bool): If the user has the right permissions for this project\n    \"\"\"\n    teamperm = Mappingnotallowed('USER_NOT_TEAM_MEMBER')\n    result = await project.getByWhere(f\" \")\n\n    # See if user is on a team with team permissions\n    level = user.getColumn(uid, 'mapping_level')\n    if level != Permissions() or Permissions():\n        pass\n\n    return False\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.permittedUser","title":"permittedUser  <code>async</code>","text":"<pre><code>permittedUser(project_id, user_id)\n</code></pre> <p>Is a user permitted to map on this project.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID to lock</p> required <code>project_id</code> <code>int</code> <p>The project this task is in</p> required <p>Returns:</p> Type Description <code>Mappingnotallowed</code> <p>The results of checking permissions</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def permittedUser(self,\n                        project_id: int,\n                        user_id: int,\n                        ):\n    \"\"\"\n    Is a user permitted to map on this project.\n\n    Args:\n        user_id (int): The user ID to lock\n        project_id (int): The project this task is in\n\n    Returns:\n        (Mappingnotallowed): The results of checking permissions\n    \"\"\"\n\n    # FIXME: is the user blocked ?\n\n    # FIXME: see it the users is allowed to work on this project\n    log.warning(f\"permittedUser(): unimplemented!\")\n    result = await self.getColumns([\"allowed_users\"],\n                                    {\"project_id\": project_id})\n\n    # FIXME: Has user accepted license\n    log.warning(f\"permittedUser(): unimplemented!\")\n    result = await self.users.getColumns([\"licenses\"],\n                                    {\"user_id\": user_id})\n    if len(result) == 0:\n        return Mappingnotallowed.USER_NOT_ACCEPTED_LICENSE\n\n    # FIXME: Then check project status\n    result = await self.getColumns([\"status\"],\n                                    {\"project_id\": project_id})\n    if len(result) == 0:\n        return Mappingnotallowed.PROJECT_NOT_PUBLISHED\n\n    # FIXME: Then see if task is already locked\n    result = await self.users.getColumns([\"task_status\"],\n                                    {\"user_id\": user_id})\n\n\n    if user_id in result[0]:\n        return Mappingnotallowed.USER_ALLOWED\n    else:\n        # FIXME: add errors\n        pass\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.toggleFavorites","title":"toggleFavorites  <code>async</code>","text":"<pre><code>toggleFavorites(flag=None)\n</code></pre> <p>Add or remove this project favorites for a user.</p> <p>Parameters:</p> Name Type Description Default <code>flag</code> <code>bool</code> <p>The value to set to, otherwise defaults to flipping it.</p> <code>None</code> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def toggleFavorites(self,\n                          flag: bool = None,\n                          ):\n    \"\"\"\n    Add or remove this project favorites for a user.\n\n    Args:\n        flag (bool): The value to set to, otherwise defaults to flipping it.\n    \"\"\"\n    log.warning(f\"toggleFavorites(): Unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.toggleFeatures","title":"toggleFeatures  <code>async</code>","text":"<pre><code>toggleFeatures(flag=None)\n</code></pre> <p>Args:</p> <p>Returns:</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def toggleFeatures(self,\n                          flag: bool = None,\n                         ):\n    \"\"\"\n\n    Args:\n\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"toggleFeatures(): Unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.unlockTasks","title":"unlockTasks  <code>async</code>","text":"<pre><code>unlockTasks(project_id)\n</code></pre> <p>Args:</p> <p>Returns:</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def unlockTasks(self,\n                          project_id: int,\n                         ):\n    \"\"\"\n\n    Args:\n\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"toggleFeatures(): Unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.getUserStats","title":"getUserStats  <code>async</code>","text":"<pre><code>getUserStats(user_id, project_id)\n</code></pre> <p>Args:</p> <p>Returns:</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def getUserStats(self,\n                        user_id: int,\n                        project_id: int,\n                         ):\n    \"\"\"\n\n    Args:\n\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"getUserStats(): Unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.getProjectStats","title":"getProjectStats  <code>async</code>","text":"<pre><code>getProjectStats(project_id)\n</code></pre> <p>Args:</p> <p>Returns:</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def getProjectStats(self,\n                         project_id: int,\n                         ):\n    \"\"\"\n\n    Args:\n\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"getProjectStats(): Unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.getAOI","title":"getAOI  <code>async</code>","text":"<pre><code>getAOI(project_id)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The project to get the data for</p> required <p>Returns:</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def getAOI(self,\n                     project_id: int,\n                     ):\n    \"\"\"\n\n    Args:\n        project_id (int): The project to get the data for\n\n    Returns:\n\n    \"\"\"\n    # log.warning(f\"getAOI(): Unimplemented!\")\n    data = await self.getColumns(['geometry'],  {\"id\": project_id})\n\n    # Convert the WKB to a Polygon.\n    return wkb.loads(data[0]['geometry'])\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.getDailyContributions","title":"getDailyContributions  <code>async</code>","text":"<pre><code>getDailyContributions(project_id)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The project to get the data for</p> required <p>Returns:</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def getDailyContributions(self,\n                           project_id: int,\n                            ):\n    \"\"\"\n\n    Args:\n        project_id (int): The project to get the data for\n\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"getDailyContributions(): Unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.ProjectsAPI.getProjectSummary","title":"getProjectSummary  <code>async</code>","text":"<pre><code>getProjectSummary()\n</code></pre> <p>Args:</p> <p>Returns:</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def getProjectSummary(self):\n    \"\"\"\n\n    Args:\n\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"getProjectSummary(): Unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/projects/#tm_admin.projects.api.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/projects/api.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-u\", \"--uri\", default='localhost/tm_admin', help=\"Database URI\")\n\n    args = parser.parse_args()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n</code></pre>"},{"location":"api/tasks/","title":"Tasks Table","text":""},{"location":"api/tasks/#taskstaskspy","title":"tasks/tasks.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/tasks/#tm_admin.tasks.tasks.TasksDB","title":"TasksDB","text":"<pre><code>TasksDB(dburi='localhost/tm_admin')\n</code></pre> <p>             Bases: <code>DBSupport</code></p> <p>Parameters:</p> Name Type Description Default <code>dburi</code> <code>str</code> <p>The URI string for the database connection.</p> <code>'localhost/tm_admin'</code> <p>Returns:</p> Type Description <code>TasksDB</code> <p>An instance of this class.</p> Source code in <code>tm_admin/tasks/tasks.py</code> <pre><code>def __init__(self,\n            dburi: str = \"localhost/tm_admin\",\n            ):\n    \"\"\"\n    A class to access the tasks table.\n\n    Args:\n        dburi (str): The URI string for the database connection.\n\n    Returns:\n        (TasksDB): An instance of this class.\n    \"\"\"\n    self.profile = TasksTable()\n    super().__init__('tasks')\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.tasks.TasksDB.mergeAnnotations","title":"mergeAnnotations  <code>async</code>","text":"<pre><code>mergeAnnotations(inpg)\n</code></pre> <p>Merge the task_annotation table from Tasking Manager into TM Admin. This table doesn't actually appear to be currently used by TM at all.</p> Source code in <code>tm_admin/tasks/tasks.py</code> <pre><code>async def mergeAnnotations(self,\n                    inpg: PostgresClient,\n                    ):\n    \"\"\"\n    Merge the task_annotation table from Tasking Manager into\n    TM Admin. This table doesn't actually appear to be currently\n    used by TM at all.\n    \"\"\"\n    table = \"task_annotations\"\n    log.error(f\"mergeAnnotations() Unimplemented as the source is empty!\")\n    timer = Timer(initial_text=\"Merging {table} table...\",\n                  text=\"merging {table table took {seconds:.0f}s\",\n                  logger=log.debug,\n                )\n    log.info(f\"Merging {table} table...\")\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.tasks.TasksDB.mergeAuxTables","title":"mergeAuxTables  <code>async</code>","text":"<pre><code>mergeAuxTables(inuri, outuri)\n</code></pre> <p>Merge more tables from TM into the unified tasks table.</p> <p>Parameters:</p> Name Type Description Default <code>inuri</code> <code>str</code> <p>The input database</p> required <code>outuri</code> <code>str</code> <p>The output database</p> required Source code in <code>tm_admin/tasks/tasks.py</code> <pre><code>async def mergeAuxTables(self,\n                         inuri: str,\n                         outuri: str,\n                         ):\n    \"\"\"\n    Merge more tables from TM into the unified tasks table.\n\n    Args:\n        inuri (str): The input database\n        outuri (str): The output database\n    \"\"\"\n    await self.connect(outuri)\n\n    inpg = PostgresClient()\n    await inpg.connect(inuri)\n\n    # FIXME: in TM, this table is empty\n    # await self.mergeAnnotations(inpg)\n\n    await self.mergeHistory(inpg)\n\n    await self.mergeInvalidations(inpg)\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.tasks.TasksDB.mergeHistory","title":"mergeHistory  <code>async</code>","text":"<pre><code>mergeHistory(inpg)\n</code></pre> <p>A method to merge the contents of the TM campaign_projects into the campaigns table as an array.</p> Source code in <code>tm_admin/tasks/tasks.py</code> <pre><code>    async def mergeHistory(self,\n                        inpg: PostgresClient,\n                        ):\n        \"\"\"\n        A method to merge the contents of the TM campaign_projects into\n        the campaigns table as an array.\n        \"\"\"\n        table = 'task_history'\n        timer = Timer(initial_text=f\"Merging {table} table...\",\n                        text=\"merging table took {seconds:.0f}s\",\n                        logger=log.debug,\n                    )\n        log.info(f\"Merging {table} table...\")\n        timer.start()\n\n        # There is a small amount of data in this table, and we need to\n        # coorelate it to the task history when merging, so read in\n        # the entire dataset.\n        sql = f\"SELECT * FROM task_mapping_issues ORDER BY id;\"\n        # print(sql)\n        data = await inpg.execute(sql)\n        entries = len(data)\n        log.debug(f\"There are {len(data)} records in task_mapping_issues\")\n        issues = dict()\n        # pbar = tqdm.tqdm(data)\n        # for record in pbar:\n        for record in data:\n            hid = record['task_history_id']\n            issues[hid] = {'issue': record['issue'],\n                           'category': record['mapping_issue_category_id'],\n                           'count': record['count'],\n                           }\n\n        # Now get the data from the history table\n        sql = f\"SELECT * FROM {table}\"\n        # print(sql)\n        data = await inpg.execute(sql)\n        entries = len(data)\n        log.debug(f\"There are {len(data)} records in {table}\")\n\n        chunk = round(entries/cores)\n\n        # FIXME: create an array of SQL queries, so later we can use\n        # prepared_queries in asyncpg for better performance. We also don't\n        # need all of the columns from the TM table, since task ID and\n        # project ID are already part of the table schema.\n        queries = list()\n        # pbar = tqdm.tqdm(data)\n        #for record in pbar:\n        for record in data:\n            entry = {\"user_id\": record['user_id']}\n            # entry['action'] = Taskaction(record['action']).name\n            entry['action'] = record['action']\n            # The action_text column often has issues with embedded\n            # quotes.\n            if record['action_text']:\n                fix = record['action_text'].replace('\"', '&amp;quot;')\n            entry['action_text'] = fix.replace(\"'\", '&amp;apos;').replace(\"\\xa0\", \"\")\n            if record['action_date']:\n                entry['action_date'] = '{:%Y-%m-%dT%H:%M:%S}'.format(record['action_date'])\n            # If there is an issue, add it to the record in the jsonb column\n            if record['id'] in issues:\n                entry.update(issues[record['id']])\n                entry.update(issues[record['id']])\n                # entry['issue'] = issues['issue']\n                # entry['category'] = issues['category']\n                # entry['count'] = issues['count']\n            asc = str(entry).replace(\"'\", '\"').replace(\"\\\\'\", \"'\")\n            sql = \"UPDATE tasks SET history = '{\\\"history\\\": [%s]}' WHERE id=%d AND project_id=%d\" % (asc, record['task_id'], record['project_id'])\n            # print(sql)\n            queries.append(sql)\n\n            # Add a timestamp to the created column so this table can\n            # be partitioned.\n            sql = f\"UPDATE tasks SET created = '{entry['action_date']}' WHERE id={record['task_id']} AND project_id={record['project_id']}\"\n            # print(sql)\n            queries.append(sql)\n\n        entries = len(queries)\n        chunk = round(entries/cores)\n        import copy\n        async with asyncio.TaskGroup() as tg:\n            for block in range(0, entries, chunk):\n                # for index in range(0, cores):\n                outpg = PostgresClient()\n                # FIXME: this should not be hard coded\n                await outpg.connect('localhost/tm_admin')\n                # FIXME: this may be removed after testing, but memory\n                # corruption errors fored this workaround.\n                foo = copy.copy(queries[block:block + chunk -1])\n                log.debug(f\"Dispatching thread {block}:{block + chunk - 1}\")\n#                await updateThread(foo, outpg)\n                # await updateThread(queries[block:block + chunk], outpg)\n                task = tg.create_task(updateThread(foo, outpg))\n        timer.stop()\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.tasks.TasksDB.mergeInvalidations","title":"mergeInvalidations  <code>async</code>","text":"<pre><code>mergeInvalidations(inpg)\n</code></pre> <p>A method to merge the contents of the TM campaign_projects into the campaigns table as an array.</p> Source code in <code>tm_admin/tasks/tasks.py</code> <pre><code>async def mergeInvalidations(self,\n                    inpg: PostgresClient,\n                    ):\n    \"\"\"\n    A method to merge the contents of the TM campaign_projects into\n    the campaigns table as an array.\n    \"\"\"\n    table = 'task_invalidation_history'\n    timer = Timer(initial_text=f\"Merging {table} table...\",\n                    text=\"merging table took {seconds:.0f}s\",\n                    logger=log.debug,\n                )\n    log.info(f\"Merging {table} table...\")\n\n    sql = f\"SELECT * FROM {table} ORDER BY project_id\"\n    # print(sql)\n    timer.start()\n    data = await inpg.execute(sql)\n    entries = len(data)\n    log.debug(f\"There are {entries} records in {table}\")\n\n    # FIXME: create an array of SQL queries, so later we can use\n    # prepared_queries in asyncpg for better performance.\n    queries = list()\n    for record in data:\n        tid = record['task_id']\n        entry = {\"mapper_id\": record['mapper_id']}\n        if record['invalidator_id']:\n            entry['invalidator_id'] = record['invalidator_id']\n        else:\n            entry['invalidator_id'] = 0\n        if record['validator_id']:\n            entry['validator_id'] = record['validator_id']\n        else:\n            entry['validator_id'] = 0\n        if record['mapped_date']:\n            entry['mapped_date'] = '{:%Y-%m-%dT%H:%M:%S}'.format(record['mapped_date'])\n        if record['invalidated_date']:\n            entry['mapped_date'] = '{:%Y-%m-%dT%H:%M:%S}'.format(record['invalidated_date'])\n        if record['validated_date']:\n            entry['mapped_date'] = '{:%Y-%m-%dT%H:%M:%S}'.format(record['validated_date'])\n        if record['updated_date']:\n            entry['mapped_date'] = '{:%Y-%m-%dT%H:%M:%S}'.format(record['updated_date'])\n        if record['is_closed']:\n            entry[\"is_closed_id\"] = \"true\"\n        else:\n            entry[\"is_closed_id\"] = \"false\"\n        # entries[record['task_id']].append(entry)\n        asc = str(entry).replace(\"'\", '\"').replace(\"\\\\'\", \"'\")\n        sql = \"UPDATE tasks SET history = '{\\\"history\\\": [%s]}' WHERE id=%d AND project_id=%d\" % (asc, record['task_id'], record['project_id'])\n        # print(sql)\n        queries.append(sql)\n\n    entries = len(queries)\n    chunk = round(entries / cores)\n    async with asyncio.TaskGroup() as tg:\n        for block in range(0, entries, chunk):\n            # for index in range(0, cores):\n            outpg = PostgresClient()\n            # FIXME: this should not be hard coded\n            await outpg.connect('localhost/tm_admin')\n            log.debug(f\"Dispatching thread {block}:{block + chunk}\")\n            #await updateThread(queries[block:block + chunk], outpg)\n            task = tg.create_task(updateThread(queries[block:block + chunk], outpg))\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.tasks.updateThread","title":"updateThread  <code>async</code>","text":"<pre><code>updateThread(queries, db)\n</code></pre> <p>Thread to handle importing data</p> <p>Parameters:</p> Name Type Description Default <code>queries</code> <code>list</code> <p>The list of SQL queries to execute</p> required <code>db</code> <code>PostgresClient</code> <p>A database connection</p> required Source code in <code>tm_admin/tasks/tasks.py</code> <pre><code>async def updateThread(\n    queries: list,\n    db: PostgresClient,\n):\n    \"\"\"Thread to handle importing data\n\n    Args:\n        queries (list): The list of SQL queries to execute\n        db (PostgresClient): A database connection\n    \"\"\"\n    pbar = tqdm.tqdm(queries)\n    for sql in pbar:\n    # for sql in queries:\n        # print(sql)\n        result = await db.execute(sql)\n\n    return True\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.tasks.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/tasks/tasks.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-i\", \"--inuri\", default='localhost/tm4',\n                            help=\"Database URI\")\n    parser.add_argument(\"-o\", \"--outuri\", default='localhost/tm_admin',\n                            help=\"Database URI\")\n    # parser.add_argument(\"-r\", \"--reset\", help=\"Reset Sequences\")\n    args = parser.parse_args()\n\n    # if len(argv) &lt;= 1:\n    #     parser.print_help()\n    #     quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    tasks = TasksDB(args.inuri)\n    await tasks.mergeAuxTables(args.inuri, args.outuri)\n</code></pre>"},{"location":"api/tasks/#taskstasks_classpy","title":"tasks/tasks_class.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/tasks/#tasksapipy","title":"tasks/api.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI","title":"TasksAPI","text":"<pre><code>TasksAPI()\n</code></pre> <p>             Bases: <code>PGSupport</code></p> <p>Returns:</p> Type Description <code>TasksAPI</code> <p>An instance of this class</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Create a class to handle the backend API calls, so the code can be shared\n    between test cases and the actual code.\n\n    Returns:\n        (TasksAPI): An instance of this class\n    \"\"\"\n    super().__init__(\"tasks\")\n    self.projects =  tm_admin.projects.api.ProjectsAPI()\n    self.users = tm_admin.users.api.UsersAPI()\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize(inuri)\n</code></pre> <p>Connect to all tables for API endpoints that require accessing multiple tables.</p> <p>Parameters:</p> Name Type Description Default <code>inuri</code> <code>str</code> <p>The URI for the TM Admin output database</p> required Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def initialize(self,\n                  inuri: str,\n                  ) -&gt; None:\n    \"\"\"\n    Connect to all tables for API endpoints that require\n    accessing multiple tables.\n\n    Args:\n        inuri (str): The URI for the TM Admin output database\n    \"\"\"\n    await self.connect(inuri)\n    await self.getTypes(\"tasks\")\n    self.projects = tm_admin.projects.api.ProjectsAPI()\n    self.users = tm_admin.users.api.UsersAPI()\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.getStatus","title":"getStatus  <code>async</code>","text":"<pre><code>getStatus(task_id, project_id)\n</code></pre> <p>Get the current status for a task using it's project and task IDs.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>The task to lock</p> required <code>project_id</code> <code>int</code> <p>The team to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the project information</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def getStatus(self,\n                  task_id: int,\n                  project_id: int,\n                ) -&gt; Taskstatus:\n    \"\"\"\n    Get the current status for a task using it's project and task IDs.\n\n    Args:\n        task_id (int): The task to lock\n        project_id (int): The team to get the data for\n\n    Returns:\n        (dict): the project information\n    \"\"\"\n    log.debug(f\"--- getByID() ---\")\n    sql = f\"SELECT task_status FROM tasks WHERE project_id={project_id} AND id={task_id}\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.getByID","title":"getByID  <code>async</code>","text":"<pre><code>getByID(task_id, project_id)\n</code></pre> <p>Get all the information for a task using it's project and task IDs.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>The task to lock</p> required <code>project_id</code> <code>int</code> <p>The team to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the project information</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def getByID(self,\n                  task_id: int,\n                  project_id: int,\n                ):\n    \"\"\"\n    Get all the information for a task using it's project and task IDs.\n\n    Args:\n        task_id (int): The task to lock\n        project_id (int): The team to get the data for\n\n    Returns:\n        (dict): the project information\n    \"\"\"\n    log.debug(f\"--- getByID() ---\")\n    sql = f\"SELECT * FROM tasks WHERE project_id={project_id} AND id={task_id}\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.getByUser","title":"getByUser  <code>async</code>","text":"<pre><code>getByUser(user_id, task_id, project_id)\n</code></pre> <p>Get all the information for a project using it's ID</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID to lock</p> required <code>task_id</code> <code>int</code> <p>The task to lock</p> required <code>project_id</code> <code>int</code> <p>The project this task is part of</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the task information</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def getByUser(self,\n                    user_id: int,\n                    task_id: int,\n                    project_id: int,\n                    ):\n    \"\"\"\n    Get all the information for a project using it's ID\n\n    Args:\n        user_id (int): The user ID to lock\n        task_id (int): The task to lock\n        project_id (int): The project this task is part of\n\n    Returns:\n        (dict): the task information\n    \"\"\"\n    log.debug(f\"--- getByID() ---\")\n    sql = f\"SELECT * FROM tasks WHERE project_id={project_id} AND id={task_id} AND user_id={user_id}\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.changeAction","title":"changeAction  <code>async</code>","text":"<pre><code>changeAction(user_id, task_id, project_id, action)\n</code></pre> <p>Manage the status of a task. This would be locking or unlocking, validation status, etc...</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The mapper locking the task</p> required <code>task_id</code> <code>int</code> <p>The task to lock</p> required <code>project_id</code> <code>int</code> <p>The project containing the task</p> required <code>action</code> <code>Taskaction</code> <p>The action to change to</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the change was sucessful</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def changeAction(self,\n                    user_id: int,\n                    task_id: int,\n                    project_id: int,\n                    action: Taskaction,\n                    ):\n    \"\"\"\n    Manage the status of a task. This would be locking or unlocking,\n    validation status, etc...\n\n    Args:\n        user_id (int): The mapper locking the task\n        task_id (int): The task to lock\n        project_id (int): The project containing the task\n        action (Taskaction): The action to change to\n\n    Returns:\n        (bool): Whether the change was sucessful\n    \"\"\"\n    # log.warning(f\"changeStatus(): unimplemented!\")\n\n    # FIXME: Make sure the user is in the allowed_user in the projects table\n    # the history\n    history = None\n    status = None\n    now = datetime.now()\n    # All actions get written to the history\n    history = {\"action\": action,\n               \"action_text\": action.name,\n               \"action_date\": '{:%Y-%m-%dT%H:%M:%S}'.format(now),\n               \"user_id\": user_id}\n    # Actions change the status\n    if action == Taskaction.LOCKED_FOR_MAPPING:\n        status = Taskstatus(Taskstatus.TASK_LOCKED_FOR_MAPPING)\n    elif action == Taskaction.LOCKED_FOR_VALIDATION:\n        status = Taskstatus(Taskstatus.TASK_LOCKED_FOR_VALIDATIONG)\n    elif action == Taskaction.STATE_CHANGE:\n        pass\n    elif action == Taskaction.COMMENT:\n        pass\n    elif action == Taskaction.AUTO_UNLOCKED_FOR_MAPPING:\n        status = Taskstatus(Taskstatus.READY)\n    elif action == Taskaction.AUTO_UNLOCKED_FOR_VALIDATION:\n        status = Taskstatus(Taskstatus.TASK_LOCKED_FOR_VALIDATION)\n    elif action == Taskaction.EXTENDED_FOR_MAPPING:\n        status = Taskactipon(Taskaction.READY) # FIXME: Huh ?\n    elif action == Taskaction.EXTENDED_FOR_VALIDATION:\n        status = Taskaction(Taskaction.READY) # FIXME: Huh ?\n    elif action == Taskaction.RELEASED_FOR_MAPPING:\n        status = Taskstatus(Taskaction.READY) # FIXME: Huh ?\n    elif action == Taskaction.MARKED_MAPPED:\n        status = Taskstatus(Taskaction.TASK_STATUS_MAPPED)\n    elif action == Taskaction.VALIDATED:\n        status = Taskstatus(Taskaction.VALIDATED)\n    elif action == Taskaction.TASK_MARKED_INVALID:\n        status = Taskstatus(Taskaction.TASK_INVALIDATED)\n    elif action == Taskaction.MARKED_BAD:\n        # FIXME: this should set the mapping issue\n        status = Taskstatus(Taskaction.READY) # FIXME: Huh ?\n    elif action == Taskaction.SPLIT_NEEDED:\n        status = Taskstatus(Taskaction.SPLIT)\n    elif action == Taskaction.RECREATED:\n        status = Taskstatus(Taskaction.READY) # FIXME: Huh ?\n\n    # FIXME: For some reason if I try to pass the dict inline,\n    # it gets converted to a set, so then fails.\n    stats = {\"task_status\": status}\n    await self.updateColumns(stats,\n                             {\"task_id\": task_id,\n                              \"project_id\": project_id})\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.lockTask","title":"lockTask  <code>async</code>","text":"<pre><code>lockTask(task_id, project_id, user_id)\n</code></pre> <p>Lock a task to a mapper</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user ID to lock</p> required <code>task_id</code> <code>int</code> <p>The task to update</p> required <code>project_id</code> <code>int</code> <p>The project this task is in</p> required <p>Returns:</p> Type Description <code>Mappingnotallowed</code> <p>If locking was sucessful or not</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def lockTask(self,\n                   task_id: int,\n                   project_id: int,\n                   user_id: int,\n                   ):\n    \"\"\"\n    Lock a task to a mapper\n\n    Args:\n        user_id (int): The user ID to lock\n        task_id (int): The task to update\n        project_id (int): The project this task is in\n\n    Returns:\n        (Mappingnotallowed): If locking was sucessful or not\n    \"\"\"\n\n    # FIXME: First see if a task is in a valid state to map.\n    # Errors from Mappingnotallowed\n\n    result = await projects.permittdUser(user_id, project_id)\n\n    if result == Mappingnotallowed.USER_ALLOWED:\n        result = await tasks.changeAction(user_id, task_id, project_id,\n                                          Taskaction.LOCKED_FOR_MAPPING)\n    else:\n        return result\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.updateHistory","title":"updateHistory  <code>async</code>","text":"<pre><code>updateHistory(history, task_id, project_id)\n</code></pre> <p>Update the task history column.</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>list</code> <p>The task history to update</p> required <code>task_id</code> <code>int</code> <p>The task to update</p> required <code>project_id</code> <code>int</code> <p>The project this task is in</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If it worked</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def updateHistory(self,\n                        history: list,\n                        task_id: int,\n                        project_id: int,\n                        ):\n    \"\"\"\n    Update the task history column.\n\n    Args:\n        history (list): The task history to update\n        task_id (int): The task to update\n        project_id (int): The project this task is in\n\n    Returns:\n        (bool): If it worked\n    \"\"\"\n    # log.warning(f\"updateHistory(): unimplemented!\")\n\n    data = str()\n    for entry in history:\n        for k, v in entry.items():\n            if str(type(v))[:5] == \"&lt;enum\":\n                data += f'\" {v.name}\", '\n            else:\n                data += f'\" {v}\", '\n            #asc = str(entry).replace(\"'\", '\"').replace(\"\\\\'\", \"'\")\n        sql = \"UPDATE tasks SET history = '{\\\"history\\\": [%s]}' WHERE id=%d AND project_id=%d\" % (data[:-2], task_id, project_id)\n        print(sql)\n        result = await self.execute(sql)\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.appendHistory","title":"appendHistory  <code>async</code>","text":"<pre><code>appendHistory(history, task_id, project_id)\n</code></pre> <p>Update the task history column.</p> <p>Parameters:</p> Name Type Description Default <code>history</code> <code>list</code> <p>The task history to update</p> required <code>task_id</code> <code>int</code> <p>The task to update</p> required <code>project_id</code> <code>int</code> <p>The project this task is in</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If it worked</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def appendHistory(self,\n                        history: list,\n                        task_id: int,\n                        project_id: int,\n                        ):\n    \"\"\"\n    Update the task history column.\n\n    Args:\n        history (list): The task history to update\n        task_id (int): The task to update\n        project_id (int): The project this task is in\n\n    Returns:\n        (bool): If it worked\n    \"\"\"\n    # log.warning(f\"updateHistory(): unimplemented!\")\n\n    data = dict()\n    data['history'] = list()\n    for entry in history:\n        # SQL wants the string value\n        if \"action\" in entry:\n            entry['action'] = entry['action'].name\n        if \"is_closed\" in entry:\n            entry['is_closed'] = str(entry['is_closed']).lower()\n        asc = str(entry).replace(\"'\", '\"').replace(\"\\\\'\", \"'\")\n        sql = \"UPDATE tasks SET history = history||'[%s]'::jsonb WHERE id=%d AND project_id=%d\" % (asc, task_id, project_id)\n        # print(sql)\n        result = await self.execute(sql)\n\n        # Update the task status\n        if \"action\" in entry:\n            status = None\n            if entry['action'] == Taskaction.VALIDATED:\n                status = Taskstatus.TASK_VALIDATED\n            elif entry['action'] == Taskaction.MARKED_INVALID:\n                status = Taskstatus.TASK_INVALIDATED\n            elif entry['action'] == Taskaction.MARKED_INVALID:\n                status = Taskstatus.TASK_VALIDATED\n            if status:\n                result = await self.updateColumns({\"status\": status},\n                                                  {\"id\": task_id,\n                                                  \"project_id\": project_id})\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.updateIssues","title":"updateIssues  <code>async</code>","text":"<pre><code>updateIssues(issues, task_id, project_id)\n</code></pre> <p>Update the task history column.</p> <p>Parameters:</p> Name Type Description Default <code>issues</code> <code>list</code> <p>The issues for this task</p> required <code>task_id</code> <code>int</code> <p>The task to update</p> required <code>project_id</code> <code>int</code> <p>The project this task is in</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If it worked</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def updateIssues(self,\n                        issues: list,\n                        task_id: int,\n                        project_id: int,\n                        ):\n    \"\"\"\n    Update the task history column.\n\n    Args:\n        issues (list): The issues for this task\n        task_id (int): The task to update\n        project_id (int): The project this task is in\n\n    Returns:\n        (bool): If it worked\n    \"\"\"\n    # log.warning(f\"updateHistory(): unimplemented!\")\n\n    data = str()\n    for entry in issues:\n        for k, v in entry.items():\n            if str(type(v))[:5] == \"&lt;enum\":\n                data += f'\" {v.name}\", '\n            else:\n                data += f'\" {v}\", '\n            #asc = str(entry).replace(\"'\", '\"').replace(\"\\\\'\", \"'\")\n        sql = \"UPDATE tasks SET issues = '{\\\"issues\\\": [%s]}' WHERE id=%d AND project_id=%d\" % (data[:-2], task_id, project_id)\n        # print(sql)\n        result = await self.execute(sql)\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.markAllMapped","title":"markAllMapped  <code>async</code>","text":"<pre><code>markAllMapped()\n</code></pre> <p>Args:</p> <p>Returns:</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def markAllMapped(self):\n    \"\"\"\n\n    Args:\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"markAllMapped(): unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.resetBadImagery","title":"resetBadImagery  <code>async</code>","text":"<pre><code>resetBadImagery()\n</code></pre> <p>Args:</p> <p>Returns:</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def resetBadImagery(self):\n    \"\"\"\n\n    Args:\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"resetBadImagery(): unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.TasksAPI.undoMapping","title":"undoMapping  <code>async</code>","text":"<pre><code>undoMapping()\n</code></pre> <p>Args:</p> <p>Returns:</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def undoMapping(self):\n    \"\"\"\n\n    Args:\n\n    Returns:\n\n    \"\"\"\n    log.warning(f\"undoMapping(): unimplemented!\")\n\n    return False\n</code></pre>"},{"location":"api/tasks/#tm_admin.tasks.api.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/tasks/api.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-u\", \"--uri\", default='localhost/tm_admin', help=\"Database URI\")\n\n    args = parser.parse_args()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n</code></pre>"},{"location":"api/users/","title":"Users Table","text":""},{"location":"api/users/#usersuserspy","title":"users/users.py","text":"<p>This class is used to import the auxilary tables into the primary table</p> <p>options: show_source: false heading_level: 3</p>"},{"location":"api/users/#tm_admin.users.users.UsersDB","title":"UsersDB","text":"<pre><code>UsersDB(dburi='localhost/tm_admin')\n</code></pre> <p>             Bases: <code>DBSupport</code></p> <p>Parameters:</p> Name Type Description Default <code>dburi</code> <code>str</code> <p>The URI string for the database connection</p> <code>'localhost/tm_admin'</code> <p>Returns:</p> Type Description <code>UsersDB</code> <p>An instance of this class</p> Source code in <code>tm_admin/users/users.py</code> <pre><code>def __init__(self,\n             dburi: str = \"localhost/tm_admin\",\n            ):\n    \"\"\"\n    A class to access the users table.\n\n    Args:\n        dburi (str): The URI string for the database connection\n\n    Returns:\n        (UsersDB): An instance of this class\n    \"\"\"\n    self.pg = None\n    self.profile = UsersTable()\n    self.types = dir(tm_admin.types_tm)\n    # super().__init__('users', dburi)\n    super().__init__('users')\n</code></pre>"},{"location":"api/users/#tm_admin.users.users.UsersDB.mergeInterests","title":"mergeInterests  <code>async</code>","text":"<pre><code>mergeInterests(inpg)\n</code></pre> <p>Merge the user_interests table from the Tasking Manager</p> <p>Parameters:</p> Name Type Description Default <code>inpg</code> <code>PostgresClient</code> <p>The input database</p> required Source code in <code>tm_admin/users/users.py</code> <pre><code>async def mergeInterests(self,\n                         inpg: PostgresClient,\n                         ):\n    \"\"\"\n    Merge the user_interests table from the Tasking Manager\n\n    Args:\n        inpg (PostgresClient): The input database\n    \"\"\"\n    table = 'user_interests'\n    timer = Timer(initial_text=\"Merging user_interests table...\",\n                  text=\"merging liceneses table took {seconds:.0f}s\",\n                  logger=log.debug,\n                )\n    log.info(f\"Merging interests table...\")\n    timer.start()\n    sql = \"SELECT * FROM user_interests ORDER BY user_id\"\n    result = await inpg.execute(sql)\n\n    # FIXME: this SQL turns out to be painfully slow, and we can create the array\n    # in python faster.\n    # await self.copyTable(table, remote)\n    # await self.renameTable(table)\n    # sql = f\"SELECT row_to_json({table}) as row FROM {table}\"\n    # Not all records in this table have data\n    # sql = f\"SELECT u.user_id,ARRAY(SELECT ARRAY(SELECT c.interest_id FROM {table} c WHERE c.user_id = u.user_id)) AS user_id FROM {table} u;\"\n    data = list()\n    entry = dict()\n    prev = None\n    # Restructure the data into a list, so we can more easily chop the data\n    # into multiple smaller pieces, one for each thread.\n    for record in result:\n        if prev == record['user_id']:\n            entry[record['user_id']].append(record['interest_id'])\n        else:\n            if len(entry) != 0:\n                data.append(entry)\n            prev = record['user_id']\n            entry = {record['user_id']: [record['interest_id']]}\n    timer.stop()\n\n    # await remote.pg.close()\n    #pg = PostgresClient()\n    entries = len(data)\n    chunk = round(entries / cores)\n\n    start = 0\n    async with asyncio.TaskGroup() as tg:\n        for block in range(0, entries, chunk):\n            # for index in range(0, cores):\n            outpg = PostgresClient()\n            await outpg.connect('localhost/tm_admin')\n            log.debug(f\"Dispatching thread {block}:{block + chunk}\")\n            # await interestsThread(data, outpg)\n            task = tg.create_task(interestsThread(data[block:block + chunk], outpg))\n\n    return True\n</code></pre>"},{"location":"api/users/#tm_admin.users.users.UsersDB.mergeLicenses","title":"mergeLicenses  <code>async</code>","text":"<pre><code>mergeLicenses(inpg)\n</code></pre> <p>Merge data from the TM user_licenses table into TM Admin. The fastest way to do a bulk update of a table is by copying the remote database table into the local database, and then merging into a new temporary table and then renaming it.</p> <p>Parameters:</p> Name Type Description Default <code>inpg</code> <code>PostgresClient</code> <p>The input database</p> required Source code in <code>tm_admin/users/users.py</code> <pre><code>async def mergeLicenses(self,\n                         inpg: PostgresClient,\n                         ):\n    \"\"\"\n    Merge data from the TM user_licenses table into TM Admin. The\n    fastest way to do a bulk update of a table is by copying the\n    remote database table into the local database, and then merging\n    into a new temporary table and then renaming it.\n\n    Args:\n        inpg (PostgresClient): The input database\n    \"\"\"\n    table = 'user_licenses'\n    # log.info(f\"Merging licenses table...\")\n    timer = Timer(initial_text=\"Merging user_licenses table...\",\n                  text=\"merging user_liceneses table took {seconds:.0f}s\",\n                  logger=log.debug,\n                )\n    timer.start()\n    sql = \"SELECT * FROM user_licenses ORDER BY user\"\n    data = await inpg.execute(sql)\n\n    entries = len(data)\n    chunk = round(entries / cores)\n\n    start = 0\n    async with asyncio.TaskGroup() as tg:\n        for block in range(0, entries, chunk):\n            # for index in range(0, cores):\n            outpg = PostgresClient()\n            await outpg.connect('localhost/tm_admin')\n            log.debug(f\"Dispatching thread {block}:{block + chunk}\")\n            # await licensesThread(data, outpg)\n            task = tg.create_task(licensesThread(data[block:block + chunk], outpg))\n\n    # self.columns = await inpg.getColumns(table)\n    # print(f\"COLUMNS: {self.columns}\")\n\n    # await self.copyTable(table, self.pg)\n    # # log.warning(f\"Merging tables can take considerable time...\")\n\n    # # cleanup old temporary tables\n    # drop = [\"DROP TABLE IF EXISTS users_bak\",\n    #         \"DROP TABLE IF EXISTS foo\"]\n    # # result = await pg.pg.executemany(drop)\n    # sql = f\"DROP TABLE IF EXISTS users_bak\"\n    # result = await self.pg.execute(sql)\n    # sql = f\"DROP TABLE IF EXISTS user_licenses\"\n    # result = await self.pg.execute(sql)\n    # sql = f\"DROP TABLE IF EXISTS new_users\"\n    # result = await self.pg.execute(sql)\n\n    # # We need to use DBLINK\n    # sql = f\"CREATE EXTENSION IF NOT EXISTS dblink;\"\n    # data = await self.pg.execute(sql)\n\n    # dbuser = self.pg.dburi[\"dbuser\"]\n    # dbpass = self.pg.dburi[\"dbpass\"]\n    # sql = f\"CREATE SERVER IF NOT EXISTS pg_rep_db FOREIGN DATA WRAPPER dblink_fdw  OPTIONS (dbname 'tm4');\"\n    # data = await self.pg.execute(sql)\n\n    # sql = f\"CREATE USER MAPPING IF NOT EXISTS FOR {dbuser} SERVER pg_rep_db OPTIONS ( user '{dbuser}', password '{dbpass}');\"\n    # result = await self.pg.execute(sql)\n\n    # # Copy table from remote database so JOIN is faster when it's in the\n    # # same database\n    # log.warning(f\"Copying a remote table is slow, but faster than remote access......\")\n    # # sql = f\"SELECT * INTO user_licenses FROM dblink('pg_rep_db','SELECT * FROM user_licenses') AS user_licenses(user_id bigint, license int)\"\n    # # print(pg.dburi)\n    # # print(sql)\n    # # result = await pg.execute(sql)\n\n    # # JOINing into a new table is much faster than doing an UPDATE\n    # sql = f\"SELECT users.*,ARRAY[user_licenses.license] INTO new_users FROM users JOIN user_licenses ON users.id=user_licenses.user_id\"\n    # result = await self.pg.execute(sql)\n\n    # # self.renameTable(table, pg)\n    # # sql = f\"ALTER TABLE users RENAME TO users_bak;\"\n    # # result = await pg.execute(sql)\n    # # sql = f\"ALTER TABLE new_users RENAME TO users;\"\n    # # result = await pg.execute(sql)\n    # # sql = f\"DROP TABLE IF EXISTS user_licenses\"\n    # # result = await pg.execute(sql)\n    timer.stop()\n</code></pre>"},{"location":"api/users/#tm_admin.users.users.UsersDB.mergeAuxTables","title":"mergeAuxTables  <code>async</code>","text":"<pre><code>mergeAuxTables(inuri, outuri)\n</code></pre> <p>Merge more tables from TM into the unified users table.</p> <p>Parameters:</p> Name Type Description Default <code>inuri</code> <code>str</code> <p>The input database</p> required <code>outuri</code> <code>str</code> <p>The output database</p> required Source code in <code>tm_admin/users/users.py</code> <pre><code>async def mergeAuxTables(self,\n                         inuri: str,\n                         outuri: str,\n                         ):\n    \"\"\"\n    Merge more tables from TM into the unified users table.\n\n    Args:\n        inuri (str): The input database\n        outuri (str): The output database        \n    \"\"\"\n    await self.connect(outuri)\n\n    inpg = PostgresClient()\n    await inpg.connect(inuri)\n\n    await self.mergeFavorites(inpg)\n\n    await self.mergeInterests(inpg)\n\n    result = await self.mergeLicenses(inpg)\n</code></pre>"},{"location":"api/users/#tm_admin.users.users.interestsThread","title":"interestsThread  <code>async</code>","text":"<pre><code>interestsThread(interests, db)\n</code></pre> <p>Thread to handle importing</p> <p>Parameters:</p> Name Type Description Default <code>interests</code> <code>list</code> <p>The list of records to import</p> required <code>db</code> <code>PostgresClient</code> <p>A database connection</p> required Source code in <code>tm_admin/users/users.py</code> <pre><code>async def interestsThread(\n    interests: list,\n    db: PostgresClient,\n):\n    \"\"\"Thread to handle importing\n\n    Args:\n        interests (list): The list of records to import\n        db (PostgresClient): A database connection\n    \"\"\"\n    pbar = tqdm.tqdm(interests)\n    for record in pbar:\n        for id, array in record.items():\n            sql = f\" UPDATE users SET interests = interests||ARRAY{array} WHERE id={id}\"\n            # print(sql)\n            result = await db.execute(sql)\n\n    return True\n</code></pre>"},{"location":"api/users/#tm_admin.users.users.favoritesThread","title":"favoritesThread  <code>async</code>","text":"<pre><code>favoritesThread(favorites, db)\n</code></pre> <p>Thread to handle importing favorites</p> <p>Parameters:</p> Name Type Description Default <code>favorites</code> <code>list</code> <p>The list of records to import</p> required <code>db</code> <code>PostgresClient</code> <p>A database connection</p> required Source code in <code>tm_admin/users/users.py</code> <pre><code>async def favoritesThread(\n    favorites: list,\n    db: PostgresClient,\n):\n    \"\"\"Thread to handle importing favorites\n\n    Args:\n        favorites (list): The list of records to import\n        db (PostgresClient): A database connection\n    \"\"\"\n    data = dict()\n    pbar = tqdm(favorites)\n    for record in pbar:\n        for id, array in record.items():\n            sql = f\" UPDATE users SET favorite_projects = ARRAY{projects} WHERE id={uid}\"\n            # print(sql)\n            result = await db.execute(f\"{sql};\")\n\n    return True\n</code></pre>"},{"location":"api/users/#tm_admin.users.users.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/users/users.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\",\n                        help=\"verbose output\")\n    parser.add_argument(\"-i\", \"--inuri\", default='localhost/tm4',\n                        help=\"Input Database URI\")\n    parser.add_argument(\"-o\", \"--outuri\", default='localhost/tm_admin',\n                        help=\"Output Database URI\")\n    # parser.add_argument(\"-r\", \"--reset\", help=\"Reset Sequences\")\n    args = parser.parse_args()\n\n    # if len(argv) &lt;= 1:\n    #     parser.print_help()\n    #     quit()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n\n    user = UsersDB()\n    # user.connect(args.uri)\n    await user.mergeAuxTables(args.inuri, args.outuri)\n</code></pre>"},{"location":"api/users/#usersusers_classpy","title":"users/users_class.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/users/#usersapipy","title":"users/api.py","text":"<p>options: show_source: false heading_level: 3</p>"},{"location":"api/users/#tm_admin.users.api.UsersAPI","title":"UsersAPI","text":"<pre><code>UsersAPI()\n</code></pre> <p>             Bases: <code>PGSupport</code></p> Source code in <code>tm_admin/users/api.py</code> <pre><code>def __init__(self):\n    self.projects = None\n    # self.projects = projects.api.ProjectsAPI()\n    self.cursor = None\n    super().__init__(\"users\")\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.initialize","title":"initialize  <code>async</code>","text":"<pre><code>initialize(inuri)\n</code></pre> <p>Connect to all tables for API endpoints that require accessing multiple tables.</p> <p>Parameters:</p> Name Type Description Default <code>inuri</code> <code>str</code> <p>The URI for the TM Admin output database</p> required Source code in <code>tm_admin/users/api.py</code> <pre><code>async def initialize(self,\n                  inuri: str,\n                  ) -&gt; None:\n    \"\"\"\n    Connect to all tables for API endpoints that require\n    accessing multiple tables.\n\n    Args:\n        inuri (str): The URI for the TM Admin output database\n    \"\"\"\n    await self.connect(inuri)\n    await self.getTypes(\"users\")\n\n    self.tasks = tm_admin.tasks.api.TasksAPI()\n    await self.tasks.initialize(inuri)\n\n    self.projects = tm_admin.projects.api.ProjectsAPI()\n    await self.projects.initialize(inuri)\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getByID","title":"getByID  <code>async</code>","text":"<pre><code>getByID(user_id)\n</code></pre> <p>Get all the information for a user using it's ID</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the user information</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getByID(self,\n                 user_id: int,\n                ):\n    \"\"\"\n    Get all the information for a user using it's ID\n\n    Args:\n        user_id (int): The user to get the data for\n\n    Returns:\n        (dict): the user information\n    \"\"\"\n    # log.debug(f\"--- getByID() ---\")\n    result = await self.getColumns(['*'], {\"id\": user_id})\n    return result\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getByName","title":"getByName  <code>async</code>","text":"<pre><code>getByName(name)\n</code></pre> <p>Get all the information for a project using the name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The project to get the data for</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the project information</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getByName(self,\n                    name: str,\n                    ):\n    \"\"\"\n    Get all the information for a project using the name\n\n    Args:\n        name (str): The project to get the data for\n\n    Returns:\n        (dict): the project information\n    \"\"\"\n    log.debug(f\"--- getByName() ---\")\n    sql = f\"SELECT * FROM users WHERE name='{name}'\"\n    results = await self.execute(sql)\n    return results\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getRole","title":"getRole  <code>async</code>","text":"<pre><code>getRole(user_id)\n</code></pre> <p>Get the role for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user's ID</p> required <p>Returns:</p> Type Description <code>Userrole</code> <p>The user's role</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getRole(self,\n              user_id: int,\n              ):\n    \"\"\"\n    Get the role for a user.\n\n    Args:\n        user_id (int): The user's ID\n\n    Returns:\n        (Userrole): The user's role\n    \"\"\"\n    result = await self.getColumns(['role'], {\"id\": user_id})\n\n    return eval(f\"Userrole.{result[0]['role']}\")\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getBlocked","title":"getBlocked  <code>async</code>","text":"<pre><code>getBlocked(user_id)\n</code></pre> <p>Get the role for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user's ID</p> required <p>Returns:</p> Type Description <code>bool</code> <p>If the user is blocked or not</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getBlocked(self,\n              user_id: int,\n              ):\n    \"\"\"\n    Get the role for a user.\n\n    Args:\n        user_id (int): The user's ID\n\n    Returns:\n        (bool): If the user is blocked or not\n    \"\"\"\n    result = await self.getColumns(['role'], {\"id\": user_id})\n\n    role = eval(f\"Userrole.{result[0]['role']}\")\n    if role == Userrole.USER_READ_ONLY:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.updateMappingLevel","title":"updateMappingLevel  <code>async</code>","text":"<pre><code>updateMappingLevel(id, level)\n</code></pre> <p>Update the mapping level for a user.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The users ID.</p> required <code>level</code> <code>Mappinglevel</code> <p>The new level.</p> required Source code in <code>tm_admin/users/api.py</code> <pre><code>async def updateMappingLevel(self,\n               id: int,\n               level: Mappinglevel,\n               ):\n    \"\"\"\n    Update the mapping level for a user.\n\n    Args:\n        id (int): The users ID.\n        level (Mappinglevel): The new level.\n    \"\"\"\n    mlevel = Mappinglevel(level)\n    result = await self.updateColumn(id, {'mapping_level': mlevel.name})\n    return result\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.updateExpert","title":"updateExpert  <code>async</code>","text":"<pre><code>updateExpert(id, mode)\n</code></pre> <p>Toggle the expert mode for a user.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The users ID.</p> required <code>mode</code> <code>bool</code> <p>The new mode..</p> required Source code in <code>tm_admin/users/api.py</code> <pre><code>async def updateExpert(self,\n               id: int,\n               mode: bool,\n               ):\n    \"\"\"\n    Toggle the expert mode for a user.\n\n    Args:\n        id (int): The users ID.\n        mode (bool): The new mode..\n    \"\"\"\n    result = await self.updateColumn(id, {'expert_mode': mode})\n    return result\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getRegistered","title":"getRegistered  <code>async</code>","text":"<pre><code>getRegistered(start, end)\n</code></pre> <p>Get all users registered in this timeframe.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime</code> <p>The starting timestamp</p> required <code>end</code> <code>datetime</code> <p>The starting timestamp</p> required <p>Returns:</p> Type Description <code>list</code> <p>The users registered in this timeframe.</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getRegistered(self,\n                  start: datetime,\n                  end: datetime,\n                  ):\n    \"\"\"\n    Get all users registered in this timeframe.\n\n    Args:\n        start (datetime): The starting timestamp\n        end (datetime): The starting timestamp\n\n    Returns:\n        (list): The users registered in this timeframe.\n    \"\"\"\n\n    where = f\" date_registered &gt; '{start}' and date_registered &lt; '{end}'\"\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getFavoriteProjects","title":"getFavoriteProjects  <code>async</code>","text":"<pre><code>getFavoriteProjects(user_id)\n</code></pre> <p>Get the data for a users favorite projects.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The user to get the favorites for</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of the projects data</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getFavoriteProjects(self,\n                              user_id: int,\n                              ):\n    \"\"\"\n    Get the data for a users favorite projects.\n\n    Args:\n        user_id (int): The user to get the favorites for\n\n    Returns:\n        (list): A list of the projects data\n    \"\"\"\n    result = await self.getColumns({\"favorite_projects\"}, {\"id\": user_id})\n    data = list()\n    for project_id in result[0]['favorite_projects']:\n        data.append(await self.projects.getByID(project_id))\n\n    return data\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getPagedUsers","title":"getPagedUsers  <code>async</code>","text":"<pre><code>getPagedUsers(\n    paged,\n    count,\n    username=None,\n    user_id=None,\n    role=None,\n    level=None,\n)\n</code></pre> <p>Get paged list of all usernames using either the user ID or a partial username.</p> <p>Parameters:</p> Name Type Description Default <code>paged</code> <code>bool</code> <p>Whether to page the results</p> required <code>count</code> <code>int</code> <p>The number of entries in the page</p> required <code>username</code> <code>str</code> <p>The partial user name</p> <code>None</code> <code>user_id</code> <code>int</code> <p>The user ID</p> <code>None</code> <code>role</code> <code>Userrole</code> <p>The user's role</p> <code>None</code> <code>level</code> <code>Mappinglevel</code> <p>The users mapping level</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>The users matching the query</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getPagedUsers(self,\n                        paged: bool,\n                        count: int,\n                        username: str = None,\n                        user_id: int = None,\n                        role: Userrole = None,\n                        level: Mappinglevel = None,\n                        ):\n    \"\"\"\n    Get paged list of all usernames using either the\n    user ID or a partial username.\n\n    Args:\n        paged (bool): Whether to page the results\n        count (int): The number of entries in the page\n        username (str): The partial user name\n        user_id (int): The user ID\n        role (Userrole): The user's role\n        level (Mappinglevel): The users mapping level\n\n    Returns:\n         (list): The users matching the query\n    \"\"\"\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getFilterUsers","title":"getFilterUsers  <code>async</code>","text":"<pre><code>getFilterUsers(\n    username, page=10, project_id=None, close=False\n)\n</code></pre> <p>\" Get paged lists of users matching OpenStreetMap using either the user ID or a partial username. The cursor gets closed when the class destructs, or by specifying the close parameter.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The partial user name</p> required <code>page</code> <code>int</code> <p>How many records in each page</p> <code>10</code> <code>project_id</code> <code>int</code> <p>Optional project ID</p> <code>None</code> <code>close</code> <code>bool</code> <p>Whether to close the cursor to restart           from the beginning.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>The users matching the query</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getFilterUsers(self,\n                         username: str,\n                         page: int = 10,\n                         project_id: int = None,\n                         close: bool = False,\n                         ):\n    \"\"\"\"\n    Get paged lists of users matching OpenStreetMap\n    using either the user ID or a partial username.\n    The cursor gets closed when the class destructs,\n    or by specifying the close parameter.\n\n    Args:\n        username (str): The partial user name\n        page (int): How many records in each page\n        project_id (int): Optional project ID\n        close (bool): Whether to close the cursor to restart\n                      from the beginning.\n\n    Returns:\n        (list): The users matching the query\n    \"\"\"\n    try:\n        result = await self.execute(f\"SELECT FROM pg_cursor WHERE name = 'user_cursor'\")\n        print(result)\n    except:\n        pass\n    if project_id:\n        self.cursor = f\"DECLARE user_cursor CURSOR WITH HOLD FOR SELECT username AS username FROM users WHERE username ILIKE '%{username}%' AND  {project_id} = ANY (projects_mapped) ORDER BY username DESC NULLS LAST, username\"\n    else:\n        self.cursor = f\"DECLARE user_cursor CURSOR WITH HOLD FOR SELECT username AS users_username FROM users WHERE username ILIKE '%{username}%' ORDER BY username DESC NULLS LAST, username\"\n    print(self.cursor)\n\n    await self.execute(self.cursor)\n    sql = f\"FETCH FORWARD {page} FROM user_cursor\"\n    return await self.execute(sql)\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getLockedTasks","title":"getLockedTasks  <code>async</code>","text":"<pre><code>getLockedTasks(username=None, user_id=None)\n</code></pre> <p>Gets any locked tasks on the project for the logged in user using either the user ID or a partial username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The partial user name</p> <code>None</code> <code>user_id</code> <code>int</code> <p>The ID of the logged in user</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>The task IDs this user has locked</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getLockedTasks(self,\n                         username: str = None,\n                         user_id: int = None,\n                         ):\n    \"\"\"\n    Gets any locked tasks on the project for the logged\n    in user using either the user ID or a partial username.\n\n    Args:\n        username (str): The partial user name\n        user_id (int): The ID of the logged in user\n\n    Returns:\n        (list): The task IDs this user has locked\n    \"\"\"\n    result = await self.getByID(user_id)\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getStats","title":"getStats  <code>async</code>","text":"<pre><code>getStats(username=None, user_id=None)\n</code></pre> <p>Get detailed statistics about a user using either the user ID or a partial username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The partial user name</p> <code>None</code> <code>user_id</code> <code>int</code> <p>The ID of the logged in user</p> <code>None</code> <p>Returns:</p> Type Description <code>UserStats</code> <p>The statistics for this user</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getStats(self,\n                   username: str = None,\n                   user_id: int = None,\n                   ):\n    \"\"\"\n    Get detailed statistics about a user using either\n    the user ID or a partial username.\n\n    Args:\n        username (str): The partial user name\n        user_id (int): The ID of the logged in user\n\n    Returns:\n        (UserStats): The statistics for this user\n    \"\"\"\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getInterestsStats","title":"getInterestsStats  <code>async</code>","text":"<pre><code>getInterestsStats(username=None, user_id=None)\n</code></pre> <p>Get rate of contributions from a user given their interests using either the user ID or a partial username.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The partial user name</p> <code>None</code> <code>user_id</code> <code>int</code> <p>The ID of the logged in user</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The rate of contributions</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getInterestsStats(self,\n                            username: str = None,\n                            user_id: int = None,\n                            ):\n    \"\"\"\n    Get rate of contributions from a user given their\n    interests using either the user ID or a partial username.\n\n    Args:\n        username (str): The partial user name\n        user_id (int): The ID of the logged in user\n\n    Returns:\n        (int): The rate of contributions\n    \"\"\"\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getAllStats","title":"getAllStats  <code>async</code>","text":"<pre><code>getAllStats(start, end)\n</code></pre> <p>Get rate of contributions from a user given their interests using either the user ID or a partial username.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime</code> <p>The starting timestamp</p> required <code>end</code> <code>datetime</code> <p>The ending timestamp</p> required <p>Returns:</p> Type Description <code>list</code> <p>A list of the stats for the users in this     time frame</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getAllStats(self,\n                      start: datetime,\n                      end: datetime,\n                      ):\n    \"\"\"\n    Get rate of contributions from a user given their\n    interests using either the user ID or a partial username.\n\n    Args:\n        start (datetime): The starting timestamp\n        end (datetime): The ending timestamp\n\n    Returns:\n        (list): A list of the stats for the users in this\n                time frame\n    \"\"\"\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.UsersAPI.getInteracts","title":"getInteracts  <code>async</code>","text":"<pre><code>getInteracts(\n    tstatus,\n    pstatus,\n    project_id,\n    start,\n    end,\n    sort,\n    page=10,\n    username=None,\n    user_id=None,\n)\n</code></pre> <p>Get a list of tasks a user has interacted with using either the user ID or a partial username.</p> <p>Sort criteria is action_date or project_id.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The partial user name</p> <code>None</code> <code>user_id</code> <code>int</code> <p>The ID of the logged in user</p> <code>None</code> <code>tstatus</code> <code>Taskstatus</code> <p>The status of the task</p> required <code>pstatus</code> <code>Projectstatus</code> <p>The status of the project</p> required <code>project_id</code> <code>int</code> <p>The project ID</p> required <code>start</code> <code>datetime</code> <p>The starting timestamp</p> required <code>end</code> <code>datetime</code> <p>The ending timestamp</p> required <code>sort</code> <code>str</code> <p>The column to use for sorting the results</p> required <code>page</code> <code>int</code> <p>How many records in each page</p> <code>10</code> <p>Returns:</p> Type Description <code>list</code> <p>FIXME! a list of task data ?</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def getInteracts(self,\n                   tstatus: Taskstatus,\n                   pstatus: Projectstatus,\n                   project_id: int,\n                   start: datetime,\n                   end: datetime,\n                   sort: str,\n                   page: int = 10,\n                   username: str = None,\n                   user_id: int = None,\n                   ):\n    \"\"\"\n    Get a list of tasks a user has interacted with\n    using either the user ID or a partial username.\n\n    Sort criteria is action_date or project_id.\n\n    Args:\n        username (str): The partial user name\n        user_id (int): The ID of the logged in user\n        tstatus (Taskstatus): The status of the task\n        pstatus (Projectstatus): The status of the project\n        project_id (int): The project ID\n        start (datetime): The starting timestamp\n        end (datetime): The ending timestamp\n        sort (str): The column to use for sorting the results\n        page (int): How many records in each page\n\n    Returns:\n        (list): FIXME! a list of task data ?\n    \"\"\"\n</code></pre>"},{"location":"api/users/#tm_admin.users.api.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> <p>This main function lets this class be run standalone by a bash script.</p> Source code in <code>tm_admin/users/api.py</code> <pre><code>async def main():\n    \"\"\"This main function lets this class be run standalone by a bash script.\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"-v\", \"--verbose\", nargs=\"?\", const=\"0\", help=\"verbose output\")\n    parser.add_argument(\"-u\", \"--uri\", default='localhost/tm_admin', help=\"Database URI\")\n\n    args = parser.parse_args()\n\n    # if verbose, dump to the terminal.\n    log_level = os.getenv(\"LOG_LEVEL\", default=\"INFO\")\n    if args.verbose is not None:\n        log_level = logging.DEBUG\n\n    logging.basicConfig(\n        level=log_level,\n        format=(\"%(asctime)s.%(msecs)03d [%(levelname)s] \" \"%(name)s | %(funcName)s:%(lineno)d | %(message)s\"),\n        datefmt=\"%y-%m-%d %H:%M:%S\",\n        stream=sys.stdout,\n    )\n</code></pre>"}]}